// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protobuf-codegen-pure=3.0.0-pre
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `message.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
pub struct VP9 {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub key: bool,
    pub pts: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a VP9 {
    fn default() -> &'a VP9 {
        <VP9 as ::protobuf::Message>::default_instance()
    }
}

impl VP9 {
    pub fn new() -> VP9 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &VP9| { &m.data },
            |m: &mut VP9| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &VP9| { &m.key },
            |m: &mut VP9| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pts",
            |m: &VP9| { &m.pts },
            |m: &mut VP9| { &mut m.pts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VP9>(
            "VP9",
            0,
            fields,
        )
    }
}

impl ::protobuf::Message for VP9 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = is.read_bytes()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key = is.read_bool()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pts = is.read_int64()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if self.key != false {
            my_size += 2;
        }
        if self.pts != 0 {
            my_size += ::protobuf::rt::value_size(3, self.pts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if self.key != false {
            os.write_bool(2, self.key)?;
        }
        if self.pts != 0 {
            os.write_int64(3, self.pts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> VP9 {
        VP9::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 0)
    }

    fn default_instance() -> &'static VP9 {
        static instance: VP9 = VP9 {
            data: ::std::vec::Vec::new(),
            key: false,
            pts: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for VP9 {
    fn clear(&mut self) {
        self.data.clear();
        self.key = false;
        self.pts = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VP9 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VP9 {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct VP9s {
    // message fields
    pub frames: ::std::vec::Vec<VP9>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a VP9s {
    fn default() -> &'a VP9s {
        <VP9s as ::protobuf::Message>::default_instance()
    }
}

impl VP9s {
    pub fn new() -> VP9s {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "frames",
            |m: &VP9s| { &m.frames },
            |m: &mut VP9s| { &mut m.frames },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VP9s>(
            "VP9s",
            1,
            fields,
        )
    }
}

impl ::protobuf::Message for VP9s {
    fn is_initialized(&self) -> bool {
        for v in &self.frames {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.frames)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.frames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.frames {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> VP9s {
        VP9s::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 1)
    }

    fn default_instance() -> &'static VP9s {
        static instance: VP9s = VP9s {
            frames: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for VP9s {
    fn clear(&mut self) {
        self.frames.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VP9s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VP9s {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct RGB {
    // message fields
    pub compress: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RGB {
    fn default() -> &'a RGB {
        <RGB as ::protobuf::Message>::default_instance()
    }
}

impl RGB {
    pub fn new() -> RGB {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compress",
            |m: &RGB| { &m.compress },
            |m: &mut RGB| { &mut m.compress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RGB>(
            "RGB",
            2,
            fields,
        )
    }
}

impl ::protobuf::Message for RGB {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.compress = is.read_bool()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.compress != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.compress != false {
            os.write_bool(1, self.compress)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RGB {
        RGB::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 2)
    }

    fn default_instance() -> &'static RGB {
        static instance: RGB = RGB {
            compress: false,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RGB {
    fn clear(&mut self) {
        self.compress = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RGB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RGB {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct YUV {
    // message fields
    pub compress: bool,
    pub stride: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a YUV {
    fn default() -> &'a YUV {
        <YUV as ::protobuf::Message>::default_instance()
    }
}

impl YUV {
    pub fn new() -> YUV {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compress",
            |m: &YUV| { &m.compress },
            |m: &mut YUV| { &mut m.compress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stride",
            |m: &YUV| { &m.stride },
            |m: &mut YUV| { &mut m.stride },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<YUV>(
            "YUV",
            3,
            fields,
        )
    }
}

impl ::protobuf::Message for YUV {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.compress = is.read_bool()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stride = is.read_int32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.compress != false {
            my_size += 2;
        }
        if self.stride != 0 {
            my_size += ::protobuf::rt::value_size(2, self.stride, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.compress != false {
            os.write_bool(1, self.compress)?;
        }
        if self.stride != 0 {
            os.write_int32(2, self.stride)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> YUV {
        YUV::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 3)
    }

    fn default_instance() -> &'static YUV {
        static instance: YUV = YUV {
            compress: false,
            stride: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for YUV {
    fn clear(&mut self) {
        self.compress = false;
        self.stride = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for YUV {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for YUV {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct VideoFrame {
    // message oneof groups
    pub union: ::std::option::Option<video_frame::Union>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoFrame {
    fn default() -> &'a VideoFrame {
        <VideoFrame as ::protobuf::Message>::default_instance()
    }
}

impl VideoFrame {
    pub fn new() -> VideoFrame {
        ::std::default::Default::default()
    }

    // .hbb.VP9s vp9s = 6;

    pub fn get_vp9s(&self) -> &VP9s {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::vp9s(ref v)) => v,
            _ => <VP9s as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_vp9s(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_vp9s(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::vp9s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vp9s(&mut self, v: VP9s) {
        self.union = ::std::option::Option::Some(video_frame::Union::vp9s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vp9s(&mut self) -> &mut VP9s {
        if let ::std::option::Option::Some(video_frame::Union::vp9s(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(video_frame::Union::vp9s(VP9s::new()));
        }
        match self.union {
            ::std::option::Option::Some(video_frame::Union::vp9s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vp9s(&mut self) -> VP9s {
        if self.has_vp9s() {
            match self.union.take() {
                ::std::option::Option::Some(video_frame::Union::vp9s(v)) => v,
                _ => panic!(),
            }
        } else {
            VP9s::new()
        }
    }

    // .hbb.RGB rgb = 7;

    pub fn get_rgb(&self) -> &RGB {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::rgb(ref v)) => v,
            _ => <RGB as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_rgb(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_rgb(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::rgb(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rgb(&mut self, v: RGB) {
        self.union = ::std::option::Option::Some(video_frame::Union::rgb(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rgb(&mut self) -> &mut RGB {
        if let ::std::option::Option::Some(video_frame::Union::rgb(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(video_frame::Union::rgb(RGB::new()));
        }
        match self.union {
            ::std::option::Option::Some(video_frame::Union::rgb(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rgb(&mut self) -> RGB {
        if self.has_rgb() {
            match self.union.take() {
                ::std::option::Option::Some(video_frame::Union::rgb(v)) => v,
                _ => panic!(),
            }
        } else {
            RGB::new()
        }
    }

    // .hbb.YUV yuv = 8;

    pub fn get_yuv(&self) -> &YUV {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::yuv(ref v)) => v,
            _ => <YUV as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_yuv(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_yuv(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::yuv(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_yuv(&mut self, v: YUV) {
        self.union = ::std::option::Option::Some(video_frame::Union::yuv(v))
    }

    // Mutable pointer to the field.
    pub fn mut_yuv(&mut self) -> &mut YUV {
        if let ::std::option::Option::Some(video_frame::Union::yuv(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(video_frame::Union::yuv(YUV::new()));
        }
        match self.union {
            ::std::option::Option::Some(video_frame::Union::yuv(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_yuv(&mut self) -> YUV {
        if self.has_yuv() {
            match self.union.take() {
                ::std::option::Option::Some(video_frame::Union::yuv(v)) => v,
                _ => panic!(),
            }
        } else {
            YUV::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VP9s>(
            "vp9s",
            VideoFrame::has_vp9s,
            VideoFrame::get_vp9s,
            VideoFrame::mut_vp9s,
            VideoFrame::set_vp9s,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RGB>(
            "rgb",
            VideoFrame::has_rgb,
            VideoFrame::get_rgb,
            VideoFrame::mut_rgb,
            VideoFrame::set_rgb,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, YUV>(
            "yuv",
            VideoFrame::has_yuv,
            VideoFrame::get_yuv,
            VideoFrame::mut_yuv,
            VideoFrame::set_yuv,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoFrame>(
            "VideoFrame",
            4,
            fields,
        )
    }
}

impl ::protobuf::Message for VideoFrame {
    fn is_initialized(&self) -> bool {
        if let Some(video_frame::Union::vp9s(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(video_frame::Union::rgb(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(video_frame::Union::yuv(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(video_frame::Union::vp9s(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(video_frame::Union::rgb(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(video_frame::Union::yuv(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &video_frame::Union::vp9s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &video_frame::Union::rgb(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &video_frame::Union::yuv(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &video_frame::Union::vp9s(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &video_frame::Union::rgb(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &video_frame::Union::yuv(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> VideoFrame {
        VideoFrame::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 4)
    }

    fn default_instance() -> &'static VideoFrame {
        static instance: VideoFrame = VideoFrame {
            union: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for VideoFrame {
    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoFrame {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VideoFrame`
pub mod video_frame {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Union {
        vp9s(super::VP9s),
        rgb(super::RGB),
        yuv(super::YUV),
    }

    impl ::protobuf::Oneof for Union {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisplayInfo {
    // message fields
    pub x: i32,
    pub y: i32,
    pub width: i32,
    pub height: i32,
    pub name: ::std::string::String,
    pub online: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisplayInfo {
    fn default() -> &'a DisplayInfo {
        <DisplayInfo as ::protobuf::Message>::default_instance()
    }
}

impl DisplayInfo {
    pub fn new() -> DisplayInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &DisplayInfo| { &m.x },
            |m: &mut DisplayInfo| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &DisplayInfo| { &m.y },
            |m: &mut DisplayInfo| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &DisplayInfo| { &m.width },
            |m: &mut DisplayInfo| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &DisplayInfo| { &m.height },
            |m: &mut DisplayInfo| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &DisplayInfo| { &m.name },
            |m: &mut DisplayInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "online",
            |m: &DisplayInfo| { &m.online },
            |m: &mut DisplayInfo| { &mut m.online },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisplayInfo>(
            "DisplayInfo",
            5,
            fields,
        )
    }
}

impl ::protobuf::Message for DisplayInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x = is.read_sint32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.y = is.read_sint32()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.width = is.read_int32()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.height = is.read_int32()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.name = is.read_string()?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.online = is.read_bool()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.y);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::value_size(3, self.width, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        if self.online != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x != 0 {
            os.write_sint32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_sint32(2, self.y)?;
        }
        if self.width != 0 {
            os.write_int32(3, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(4, self.height)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        if self.online != false {
            os.write_bool(6, self.online)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> DisplayInfo {
        DisplayInfo::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 5)
    }

    fn default_instance() -> &'static DisplayInfo {
        static instance: DisplayInfo = DisplayInfo {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            name: ::std::string::String::new(),
            online: false,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for DisplayInfo {
    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.width = 0;
        self.height = 0;
        self.name.clear();
        self.online = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisplayInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisplayInfo {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PortForward {
    // message fields
    pub host: ::std::string::String,
    pub port: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortForward {
    fn default() -> &'a PortForward {
        <PortForward as ::protobuf::Message>::default_instance()
    }
}

impl PortForward {
    pub fn new() -> PortForward {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "host",
            |m: &PortForward| { &m.host },
            |m: &mut PortForward| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &PortForward| { &m.port },
            |m: &mut PortForward| { &mut m.port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PortForward>(
            "PortForward",
            6,
            fields,
        )
    }
}

impl ::protobuf::Message for PortForward {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.host = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.port = is.read_int32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if self.port != 0 {
            os.write_int32(2, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PortForward {
        PortForward::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 6)
    }

    fn default_instance() -> &'static PortForward {
        static instance: PortForward = PortForward {
            host: ::std::string::String::new(),
            port: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PortForward {
    fn clear(&mut self) {
        self.host.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortForward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortForward {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct FileTransfer {
    // message fields
    pub dir: ::std::string::String,
    pub show_hidden: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileTransfer {
    fn default() -> &'a FileTransfer {
        <FileTransfer as ::protobuf::Message>::default_instance()
    }
}

impl FileTransfer {
    pub fn new() -> FileTransfer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dir",
            |m: &FileTransfer| { &m.dir },
            |m: &mut FileTransfer| { &mut m.dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "show_hidden",
            |m: &FileTransfer| { &m.show_hidden },
            |m: &mut FileTransfer| { &mut m.show_hidden },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransfer>(
            "FileTransfer",
            7,
            fields,
        )
    }
}

impl ::protobuf::Message for FileTransfer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.dir = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.show_hidden = is.read_bool()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dir.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dir);
        }
        if self.show_hidden != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dir.is_empty() {
            os.write_string(1, &self.dir)?;
        }
        if self.show_hidden != false {
            os.write_bool(2, self.show_hidden)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FileTransfer {
        FileTransfer::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 7)
    }

    fn default_instance() -> &'static FileTransfer {
        static instance: FileTransfer = FileTransfer {
            dir: ::std::string::String::new(),
            show_hidden: false,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FileTransfer {
    fn clear(&mut self) {
        self.dir.clear();
        self.show_hidden = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileTransfer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransfer {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct LoginRequest {
    // message fields
    pub username: ::std::string::String,
    pub password: ::std::vec::Vec<u8>,
    pub my_id: ::std::string::String,
    pub my_name: ::std::string::String,
    pub option: ::protobuf::MessageField<OptionMessage>,
    // message oneof groups
    pub union: ::std::option::Option<login_request::Union>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoginRequest {
    fn default() -> &'a LoginRequest {
        <LoginRequest as ::protobuf::Message>::default_instance()
    }
}

impl LoginRequest {
    pub fn new() -> LoginRequest {
        ::std::default::Default::default()
    }

    // .hbb.FileTransfer file_transfer = 7;

    pub fn get_file_transfer(&self) -> &FileTransfer {
        match self.union {
            ::std::option::Option::Some(login_request::Union::file_transfer(ref v)) => v,
            _ => <FileTransfer as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_file_transfer(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_file_transfer(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(login_request::Union::file_transfer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_transfer(&mut self, v: FileTransfer) {
        self.union = ::std::option::Option::Some(login_request::Union::file_transfer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_transfer(&mut self) -> &mut FileTransfer {
        if let ::std::option::Option::Some(login_request::Union::file_transfer(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(login_request::Union::file_transfer(FileTransfer::new()));
        }
        match self.union {
            ::std::option::Option::Some(login_request::Union::file_transfer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_transfer(&mut self) -> FileTransfer {
        if self.has_file_transfer() {
            match self.union.take() {
                ::std::option::Option::Some(login_request::Union::file_transfer(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransfer::new()
        }
    }

    // .hbb.PortForward port_forward = 8;

    pub fn get_port_forward(&self) -> &PortForward {
        match self.union {
            ::std::option::Option::Some(login_request::Union::port_forward(ref v)) => v,
            _ => <PortForward as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_port_forward(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_port_forward(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(login_request::Union::port_forward(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_port_forward(&mut self, v: PortForward) {
        self.union = ::std::option::Option::Some(login_request::Union::port_forward(v))
    }

    // Mutable pointer to the field.
    pub fn mut_port_forward(&mut self) -> &mut PortForward {
        if let ::std::option::Option::Some(login_request::Union::port_forward(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(login_request::Union::port_forward(PortForward::new()));
        }
        match self.union {
            ::std::option::Option::Some(login_request::Union::port_forward(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_port_forward(&mut self) -> PortForward {
        if self.has_port_forward() {
            match self.union.take() {
                ::std::option::Option::Some(login_request::Union::port_forward(v)) => v,
                _ => panic!(),
            }
        } else {
            PortForward::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "username",
            |m: &LoginRequest| { &m.username },
            |m: &mut LoginRequest| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password",
            |m: &LoginRequest| { &m.password },
            |m: &mut LoginRequest| { &mut m.password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "my_id",
            |m: &LoginRequest| { &m.my_id },
            |m: &mut LoginRequest| { &mut m.my_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "my_name",
            |m: &LoginRequest| { &m.my_name },
            |m: &mut LoginRequest| { &mut m.my_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OptionMessage>(
            "option",
            |m: &LoginRequest| { &m.option },
            |m: &mut LoginRequest| { &mut m.option },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransfer>(
            "file_transfer",
            LoginRequest::has_file_transfer,
            LoginRequest::get_file_transfer,
            LoginRequest::mut_file_transfer,
            LoginRequest::set_file_transfer,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PortForward>(
            "port_forward",
            LoginRequest::has_port_forward,
            LoginRequest::get_port_forward,
            LoginRequest::mut_port_forward,
            LoginRequest::set_port_forward,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginRequest>(
            "LoginRequest",
            8,
            fields,
        )
    }
}

impl ::protobuf::Message for LoginRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.option {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(login_request::Union::file_transfer(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(login_request::Union::port_forward(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.username = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.password = is.read_bytes()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.my_id = is.read_string()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.my_name = is.read_string()?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.option)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(login_request::Union::file_transfer(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(login_request::Union::port_forward(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.password);
        }
        if !self.my_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.my_id);
        }
        if !self.my_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.my_name);
        }
        if let Some(v) = self.option.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &login_request::Union::file_transfer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &login_request::Union::port_forward(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_bytes(2, &self.password)?;
        }
        if !self.my_id.is_empty() {
            os.write_string(4, &self.my_id)?;
        }
        if !self.my_name.is_empty() {
            os.write_string(5, &self.my_name)?;
        }
        if let Some(v) = self.option.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &login_request::Union::file_transfer(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &login_request::Union::port_forward(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> LoginRequest {
        LoginRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 8)
    }

    fn default_instance() -> &'static LoginRequest {
        static instance: LoginRequest = LoginRequest {
            username: ::std::string::String::new(),
            password: ::std::vec::Vec::new(),
            my_id: ::std::string::String::new(),
            my_name: ::std::string::String::new(),
            option: ::protobuf::MessageField::none(),
            union: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for LoginRequest {
    fn clear(&mut self) {
        self.username.clear();
        self.password.clear();
        self.my_id.clear();
        self.my_name.clear();
        self.option.clear();
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LoginRequest`
pub mod login_request {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Union {
        file_transfer(super::FileTransfer),
        port_forward(super::PortForward),
    }

    impl ::protobuf::Oneof for Union {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChatMessage {
    // message fields
    pub text: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChatMessage {
    fn default() -> &'a ChatMessage {
        <ChatMessage as ::protobuf::Message>::default_instance()
    }
}

impl ChatMessage {
    pub fn new() -> ChatMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "text",
            |m: &ChatMessage| { &m.text },
            |m: &mut ChatMessage| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChatMessage>(
            "ChatMessage",
            9,
            fields,
        )
    }
}

impl ::protobuf::Message for ChatMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.text = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.text.is_empty() {
            os.write_string(1, &self.text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ChatMessage {
        ChatMessage::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 9)
    }

    fn default_instance() -> &'static ChatMessage {
        static instance: ChatMessage = ChatMessage {
            text: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ChatMessage {
    fn clear(&mut self) {
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChatMessage {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PeerInfo {
    // message fields
    pub username: ::std::string::String,
    pub hostname: ::std::string::String,
    pub platform: ::std::string::String,
    pub displays: ::std::vec::Vec<DisplayInfo>,
    pub current_display: i32,
    pub sas_enabled: bool,
    pub version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeerInfo {
    fn default() -> &'a PeerInfo {
        <PeerInfo as ::protobuf::Message>::default_instance()
    }
}

impl PeerInfo {
    pub fn new() -> PeerInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "username",
            |m: &PeerInfo| { &m.username },
            |m: &mut PeerInfo| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hostname",
            |m: &PeerInfo| { &m.hostname },
            |m: &mut PeerInfo| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "platform",
            |m: &PeerInfo| { &m.platform },
            |m: &mut PeerInfo| { &mut m.platform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "displays",
            |m: &PeerInfo| { &m.displays },
            |m: &mut PeerInfo| { &mut m.displays },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current_display",
            |m: &PeerInfo| { &m.current_display },
            |m: &mut PeerInfo| { &mut m.current_display },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sas_enabled",
            |m: &PeerInfo| { &m.sas_enabled },
            |m: &mut PeerInfo| { &mut m.sas_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &PeerInfo| { &m.version },
            |m: &mut PeerInfo| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeerInfo>(
            "PeerInfo",
            10,
            fields,
        )
    }
}

impl ::protobuf::Message for PeerInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.displays {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.username = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hostname = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.platform = is.read_string()?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.displays)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.current_display = is.read_int32()?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sas_enabled = is.read_bool()?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.version = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.hostname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.hostname);
        }
        if !self.platform.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.platform);
        }
        for value in &self.displays {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.current_display != 0 {
            my_size += ::protobuf::rt::value_size(5, self.current_display, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sas_enabled != false {
            my_size += 2;
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.hostname.is_empty() {
            os.write_string(2, &self.hostname)?;
        }
        if !self.platform.is_empty() {
            os.write_string(3, &self.platform)?;
        }
        for v in &self.displays {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if self.current_display != 0 {
            os.write_int32(5, self.current_display)?;
        }
        if self.sas_enabled != false {
            os.write_bool(6, self.sas_enabled)?;
        }
        if !self.version.is_empty() {
            os.write_string(7, &self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PeerInfo {
        PeerInfo::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 10)
    }

    fn default_instance() -> &'static PeerInfo {
        static instance: PeerInfo = PeerInfo {
            username: ::std::string::String::new(),
            hostname: ::std::string::String::new(),
            platform: ::std::string::String::new(),
            displays: ::std::vec::Vec::new(),
            current_display: 0,
            sas_enabled: false,
            version: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PeerInfo {
    fn clear(&mut self) {
        self.username.clear();
        self.hostname.clear();
        self.platform.clear();
        self.displays.clear();
        self.current_display = 0;
        self.sas_enabled = false;
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PeerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerInfo {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct LoginResponse {
    // message oneof groups
    pub union: ::std::option::Option<login_response::Union>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoginResponse {
    fn default() -> &'a LoginResponse {
        <LoginResponse as ::protobuf::Message>::default_instance()
    }
}

impl LoginResponse {
    pub fn new() -> LoginResponse {
        ::std::default::Default::default()
    }

    // string error = 1;

    pub fn get_error(&self) -> &str {
        match self.union {
            ::std::option::Option::Some(login_response::Union::error(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(login_response::Union::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.union = ::std::option::Option::Some(login_response::Union::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(login_response::Union::error(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(login_response::Union::error(::std::string::String::new()));
        }
        match self.union {
            ::std::option::Option::Some(login_response::Union::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        if self.has_error() {
            match self.union.take() {
                ::std::option::Option::Some(login_response::Union::error(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .hbb.PeerInfo peer_info = 2;

    pub fn get_peer_info(&self) -> &PeerInfo {
        match self.union {
            ::std::option::Option::Some(login_response::Union::peer_info(ref v)) => v,
            _ => <PeerInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_peer_info(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_peer_info(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(login_response::Union::peer_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_peer_info(&mut self, v: PeerInfo) {
        self.union = ::std::option::Option::Some(login_response::Union::peer_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_peer_info(&mut self) -> &mut PeerInfo {
        if let ::std::option::Option::Some(login_response::Union::peer_info(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(login_response::Union::peer_info(PeerInfo::new()));
        }
        match self.union {
            ::std::option::Option::Some(login_response::Union::peer_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_peer_info(&mut self) -> PeerInfo {
        if self.has_peer_info() {
            match self.union.take() {
                ::std::option::Option::Some(login_response::Union::peer_info(v)) => v,
                _ => panic!(),
            }
        } else {
            PeerInfo::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "error",
            LoginResponse::has_error,
            LoginResponse::get_error,
            LoginResponse::set_error,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PeerInfo>(
            "peer_info",
            LoginResponse::has_peer_info,
            LoginResponse::get_peer_info,
            LoginResponse::mut_peer_info,
            LoginResponse::set_peer_info,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginResponse>(
            "LoginResponse",
            11,
            fields,
        )
    }
}

impl ::protobuf::Message for LoginResponse {
    fn is_initialized(&self) -> bool {
        if let Some(login_response::Union::peer_info(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(login_response::Union::error(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(login_response::Union::peer_info(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &login_response::Union::error(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &login_response::Union::peer_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &login_response::Union::error(ref v) => {
                    os.write_string(1, v)?;
                },
                &login_response::Union::peer_info(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> LoginResponse {
        LoginResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 11)
    }

    fn default_instance() -> &'static LoginResponse {
        static instance: LoginResponse = LoginResponse {
            union: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for LoginResponse {
    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LoginResponse`
pub mod login_response {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Union {
        error(::std::string::String),
        peer_info(super::PeerInfo),
    }

    impl ::protobuf::Oneof for Union {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MouseEvent {
    // message fields
    pub mask: i32,
    pub x: i32,
    pub y: i32,
    pub modifiers: ::std::vec::Vec<::protobuf::ProtobufEnumOrUnknown<ControlKey>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a MouseEvent {
    fn default() -> &'a MouseEvent {
        <MouseEvent as ::protobuf::Message>::default_instance()
    }
}

impl MouseEvent {
    pub fn new() -> MouseEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mask",
            |m: &MouseEvent| { &m.mask },
            |m: &mut MouseEvent| { &mut m.mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &MouseEvent| { &m.x },
            |m: &mut MouseEvent| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &MouseEvent| { &m.y },
            |m: &mut MouseEvent| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modifiers",
            |m: &MouseEvent| { &m.modifiers },
            |m: &mut MouseEvent| { &mut m.modifiers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MouseEvent>(
            "MouseEvent",
            12,
            fields,
        )
    }
}

impl ::protobuf::Message for MouseEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mask = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x = is.read_sint32()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.y = is.read_sint32()?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_enum_or_unknown_into(wire_type, is, &mut self.modifiers)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mask != 0 {
            my_size += ::protobuf::rt::value_size(1, self.mask, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.x != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.y);
        }
        for value in &self.modifiers {
            my_size += ::protobuf::rt::enum_or_unknown_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.mask != 0 {
            os.write_int32(1, self.mask)?;
        }
        if self.x != 0 {
            os.write_sint32(2, self.x)?;
        }
        if self.y != 0 {
            os.write_sint32(3, self.y)?;
        }
        for v in &self.modifiers {
            os.write_enum(4, ::protobuf::ProtobufEnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> MouseEvent {
        MouseEvent::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 12)
    }

    fn default_instance() -> &'static MouseEvent {
        static instance: MouseEvent = MouseEvent {
            mask: 0,
            x: 0,
            y: 0,
            modifiers: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for MouseEvent {
    fn clear(&mut self) {
        self.mask = 0;
        self.x = 0;
        self.y = 0;
        self.modifiers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MouseEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MouseEvent {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyEvent {
    // message fields
    pub down: bool,
    pub press: bool,
    pub modifiers: ::std::vec::Vec<::protobuf::ProtobufEnumOrUnknown<ControlKey>>,
    // message oneof groups
    pub union: ::std::option::Option<key_event::Union>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyEvent {
    fn default() -> &'a KeyEvent {
        <KeyEvent as ::protobuf::Message>::default_instance()
    }
}

impl KeyEvent {
    pub fn new() -> KeyEvent {
        ::std::default::Default::default()
    }

    // .hbb.ControlKey control_key = 3;

    pub fn get_control_key(&self) -> ControlKey {
        match self.union {
            ::std::option::Option::Some(key_event::Union::control_key(v)) => ::protobuf::ProtobufEnumOrUnknown::enum_value_or_default(&v),
            _ => ControlKey::Alt,
        }
    }

    pub fn clear_control_key(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_control_key(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(key_event::Union::control_key(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_control_key(&mut self, v: ControlKey) {
        self.union = ::std::option::Option::Some(key_event::Union::control_key(::protobuf::ProtobufEnumOrUnknown::new(v)))
    }

    // uint32 chr = 4;

    pub fn get_chr(&self) -> u32 {
        match self.union {
            ::std::option::Option::Some(key_event::Union::chr(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_chr(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_chr(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(key_event::Union::chr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chr(&mut self, v: u32) {
        self.union = ::std::option::Option::Some(key_event::Union::chr(v))
    }

    // uint32 unicode = 5;

    pub fn get_unicode(&self) -> u32 {
        match self.union {
            ::std::option::Option::Some(key_event::Union::unicode(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_unicode(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_unicode(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(key_event::Union::unicode(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unicode(&mut self, v: u32) {
        self.union = ::std::option::Option::Some(key_event::Union::unicode(v))
    }

    // string seq = 6;

    pub fn get_seq(&self) -> &str {
        match self.union {
            ::std::option::Option::Some(key_event::Union::seq(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_seq(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_seq(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(key_event::Union::seq(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: ::std::string::String) {
        self.union = ::std::option::Option::Some(key_event::Union::seq(v))
    }

    // Mutable pointer to the field.
    pub fn mut_seq(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(key_event::Union::seq(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(key_event::Union::seq(::std::string::String::new()));
        }
        match self.union {
            ::std::option::Option::Some(key_event::Union::seq(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_seq(&mut self) -> ::std::string::String {
        if self.has_seq() {
            match self.union.take() {
                ::std::option::Option::Some(key_event::Union::seq(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "down",
            |m: &KeyEvent| { &m.down },
            |m: &mut KeyEvent| { &mut m.down },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "press",
            |m: &KeyEvent| { &m.press },
            |m: &mut KeyEvent| { &mut m.press },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "control_key",
            KeyEvent::has_control_key,
            KeyEvent::get_control_key,
            KeyEvent::set_control_key,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "chr",
            KeyEvent::has_chr,
            KeyEvent::get_chr,
            KeyEvent::set_chr,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "unicode",
            KeyEvent::has_unicode,
            KeyEvent::get_unicode,
            KeyEvent::set_unicode,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "seq",
            KeyEvent::has_seq,
            KeyEvent::get_seq,
            KeyEvent::set_seq,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modifiers",
            |m: &KeyEvent| { &m.modifiers },
            |m: &mut KeyEvent| { &mut m.modifiers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyEvent>(
            "KeyEvent",
            13,
            fields,
        )
    }
}

impl ::protobuf::Message for KeyEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.down = is.read_bool()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.press = is.read_bool()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(key_event::Union::control_key(is.read_enum_or_unknown()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(key_event::Union::chr(is.read_uint32()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(key_event::Union::unicode(is.read_uint32()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(key_event::Union::seq(is.read_string()?));
                },
                8 => {
                    ::protobuf::rt::read_repeated_enum_or_unknown_into(wire_type, is, &mut self.modifiers)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.down != false {
            my_size += 2;
        }
        if self.press != false {
            my_size += 2;
        }
        for value in &self.modifiers {
            my_size += ::protobuf::rt::enum_or_unknown_size(8, *value);
        };
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &key_event::Union::control_key(v) => {
                    my_size += ::protobuf::rt::enum_or_unknown_size(3, v);
                },
                &key_event::Union::chr(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &key_event::Union::unicode(v) => {
                    my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &key_event::Union::seq(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.down != false {
            os.write_bool(1, self.down)?;
        }
        if self.press != false {
            os.write_bool(2, self.press)?;
        }
        for v in &self.modifiers {
            os.write_enum(8, ::protobuf::ProtobufEnumOrUnknown::value(v))?;
        };
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &key_event::Union::control_key(v) => {
                    os.write_enum(3, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
                },
                &key_event::Union::chr(v) => {
                    os.write_uint32(4, v)?;
                },
                &key_event::Union::unicode(v) => {
                    os.write_uint32(5, v)?;
                },
                &key_event::Union::seq(ref v) => {
                    os.write_string(6, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> KeyEvent {
        KeyEvent::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 13)
    }

    fn default_instance() -> &'static KeyEvent {
        static instance: KeyEvent = KeyEvent {
            down: false,
            press: false,
            modifiers: ::std::vec::Vec::new(),
            union: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for KeyEvent {
    fn clear(&mut self) {
        self.down = false;
        self.press = false;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.modifiers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyEvent {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `KeyEvent`
pub mod key_event {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Union {
        control_key(::protobuf::ProtobufEnumOrUnknown<super::ControlKey>),
        chr(u32),
        unicode(u32),
        seq(::std::string::String),
    }

    impl ::protobuf::Oneof for Union {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CursorData {
    // message fields
    pub id: u64,
    pub hotx: i32,
    pub hoty: i32,
    pub width: i32,
    pub height: i32,
    pub colors: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CursorData {
    fn default() -> &'a CursorData {
        <CursorData as ::protobuf::Message>::default_instance()
    }
}

impl CursorData {
    pub fn new() -> CursorData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CursorData| { &m.id },
            |m: &mut CursorData| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hotx",
            |m: &CursorData| { &m.hotx },
            |m: &mut CursorData| { &mut m.hotx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hoty",
            |m: &CursorData| { &m.hoty },
            |m: &mut CursorData| { &mut m.hoty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &CursorData| { &m.width },
            |m: &mut CursorData| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &CursorData| { &m.height },
            |m: &mut CursorData| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "colors",
            |m: &CursorData| { &m.colors },
            |m: &mut CursorData| { &mut m.colors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CursorData>(
            "CursorData",
            14,
            fields,
        )
    }
}

impl ::protobuf::Message for CursorData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = is.read_uint64()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hotx = is.read_sint32()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hoty = is.read_sint32()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.width = is.read_int32()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.height = is.read_int32()?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.colors = is.read_bytes()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.hotx != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.hotx);
        }
        if self.hoty != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.hoty);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::value_size(4, self.width, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(5, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.colors.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.colors);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if self.hotx != 0 {
            os.write_sint32(2, self.hotx)?;
        }
        if self.hoty != 0 {
            os.write_sint32(3, self.hoty)?;
        }
        if self.width != 0 {
            os.write_int32(4, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(5, self.height)?;
        }
        if !self.colors.is_empty() {
            os.write_bytes(6, &self.colors)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> CursorData {
        CursorData::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 14)
    }

    fn default_instance() -> &'static CursorData {
        static instance: CursorData = CursorData {
            id: 0,
            hotx: 0,
            hoty: 0,
            width: 0,
            height: 0,
            colors: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for CursorData {
    fn clear(&mut self) {
        self.id = 0;
        self.hotx = 0;
        self.hoty = 0;
        self.width = 0;
        self.height = 0;
        self.colors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CursorData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CursorData {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct CursorPosition {
    // message fields
    pub x: i32,
    pub y: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CursorPosition {
    fn default() -> &'a CursorPosition {
        <CursorPosition as ::protobuf::Message>::default_instance()
    }
}

impl CursorPosition {
    pub fn new() -> CursorPosition {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &CursorPosition| { &m.x },
            |m: &mut CursorPosition| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &CursorPosition| { &m.y },
            |m: &mut CursorPosition| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CursorPosition>(
            "CursorPosition",
            15,
            fields,
        )
    }
}

impl ::protobuf::Message for CursorPosition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x = is.read_sint32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.y = is.read_sint32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.y);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x != 0 {
            os.write_sint32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_sint32(2, self.y)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> CursorPosition {
        CursorPosition::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 15)
    }

    fn default_instance() -> &'static CursorPosition {
        static instance: CursorPosition = CursorPosition {
            x: 0,
            y: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for CursorPosition {
    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CursorPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CursorPosition {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Hash {
    // message fields
    pub salt: ::std::string::String,
    pub challenge: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Hash {
    fn default() -> &'a Hash {
        <Hash as ::protobuf::Message>::default_instance()
    }
}

impl Hash {
    pub fn new() -> Hash {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "salt",
            |m: &Hash| { &m.salt },
            |m: &mut Hash| { &mut m.salt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "challenge",
            |m: &Hash| { &m.challenge },
            |m: &mut Hash| { &mut m.challenge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Hash>(
            "Hash",
            16,
            fields,
        )
    }
}

impl ::protobuf::Message for Hash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.salt = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.challenge = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.salt.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.salt);
        }
        if !self.challenge.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.challenge);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.salt.is_empty() {
            os.write_string(1, &self.salt)?;
        }
        if !self.challenge.is_empty() {
            os.write_string(2, &self.challenge)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Hash {
        Hash::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 16)
    }

    fn default_instance() -> &'static Hash {
        static instance: Hash = Hash {
            salt: ::std::string::String::new(),
            challenge: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Hash {
    fn clear(&mut self) {
        self.salt.clear();
        self.challenge.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Hash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hash {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Clipboard {
    // message fields
    pub compress: bool,
    pub content: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Clipboard {
    fn default() -> &'a Clipboard {
        <Clipboard as ::protobuf::Message>::default_instance()
    }
}

impl Clipboard {
    pub fn new() -> Clipboard {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compress",
            |m: &Clipboard| { &m.compress },
            |m: &mut Clipboard| { &mut m.compress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &Clipboard| { &m.content },
            |m: &mut Clipboard| { &mut m.content },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Clipboard>(
            "Clipboard",
            17,
            fields,
        )
    }
}

impl ::protobuf::Message for Clipboard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.compress = is.read_bool()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = is.read_bytes()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.compress != false {
            my_size += 2;
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.content);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.compress != false {
            os.write_bool(1, self.compress)?;
        }
        if !self.content.is_empty() {
            os.write_bytes(2, &self.content)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Clipboard {
        Clipboard::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 17)
    }

    fn default_instance() -> &'static Clipboard {
        static instance: Clipboard = Clipboard {
            compress: false,
            content: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Clipboard {
    fn clear(&mut self) {
        self.compress = false;
        self.content.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Clipboard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Clipboard {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct FileEntry {
    // message fields
    pub entry_type: ::protobuf::ProtobufEnumOrUnknown<FileType>,
    pub name: ::std::string::String,
    pub is_hidden: bool,
    pub size: u64,
    pub modified_time: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileEntry {
    fn default() -> &'a FileEntry {
        <FileEntry as ::protobuf::Message>::default_instance()
    }
}

impl FileEntry {
    pub fn new() -> FileEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entry_type",
            |m: &FileEntry| { &m.entry_type },
            |m: &mut FileEntry| { &mut m.entry_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &FileEntry| { &m.name },
            |m: &mut FileEntry| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_hidden",
            |m: &FileEntry| { &m.is_hidden },
            |m: &mut FileEntry| { &mut m.is_hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "size",
            |m: &FileEntry| { &m.size },
            |m: &mut FileEntry| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "modified_time",
            |m: &FileEntry| { &m.modified_time },
            |m: &mut FileEntry| { &mut m.modified_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileEntry>(
            "FileEntry",
            18,
            fields,
        )
    }
}

impl ::protobuf::Message for FileEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entry_type = is.read_enum_or_unknown()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.name = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_hidden = is.read_bool()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.size = is.read_uint64()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.modified_time = is.read_uint64()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.entry_type != ::protobuf::ProtobufEnumOrUnknown::new(FileType::Dir) {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, self.entry_type);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.is_hidden != false {
            my_size += 2;
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.modified_time != 0 {
            my_size += ::protobuf::rt::value_size(5, self.modified_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.entry_type != ::protobuf::ProtobufEnumOrUnknown::new(FileType::Dir) {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&self.entry_type))?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.is_hidden != false {
            os.write_bool(3, self.is_hidden)?;
        }
        if self.size != 0 {
            os.write_uint64(4, self.size)?;
        }
        if self.modified_time != 0 {
            os.write_uint64(5, self.modified_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FileEntry {
        FileEntry::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 18)
    }

    fn default_instance() -> &'static FileEntry {
        static instance: FileEntry = FileEntry {
            entry_type: ::protobuf::ProtobufEnumOrUnknown::from_i32(1),
            name: ::std::string::String::new(),
            is_hidden: false,
            size: 0,
            modified_time: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FileEntry {
    fn clear(&mut self) {
        self.entry_type = ::protobuf::ProtobufEnumOrUnknown::new(FileType::Dir);
        self.name.clear();
        self.is_hidden = false;
        self.size = 0;
        self.modified_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileEntry {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct FileDirectory {
    // message fields
    pub id: i32,
    pub path: ::std::string::String,
    pub entries: ::std::vec::Vec<FileEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileDirectory {
    fn default() -> &'a FileDirectory {
        <FileDirectory as ::protobuf::Message>::default_instance()
    }
}

impl FileDirectory {
    pub fn new() -> FileDirectory {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileDirectory| { &m.id },
            |m: &mut FileDirectory| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileDirectory| { &m.path },
            |m: &mut FileDirectory| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &FileDirectory| { &m.entries },
            |m: &mut FileDirectory| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileDirectory>(
            "FileDirectory",
            19,
            fields,
        )
    }
}

impl ::protobuf::Message for FileDirectory {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path = is.read_string()?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FileDirectory {
        FileDirectory::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 19)
    }

    fn default_instance() -> &'static FileDirectory {
        static instance: FileDirectory = FileDirectory {
            id: 0,
            path: ::std::string::String::new(),
            entries: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FileDirectory {
    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileDirectory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileDirectory {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadDir {
    // message fields
    pub path: ::std::string::String,
    pub include_hidden: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadDir {
    fn default() -> &'a ReadDir {
        <ReadDir as ::protobuf::Message>::default_instance()
    }
}

impl ReadDir {
    pub fn new() -> ReadDir {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &ReadDir| { &m.path },
            |m: &mut ReadDir| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_hidden",
            |m: &ReadDir| { &m.include_hidden },
            |m: &mut ReadDir| { &mut m.include_hidden },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadDir>(
            "ReadDir",
            20,
            fields,
        )
    }
}

impl ::protobuf::Message for ReadDir {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.include_hidden = is.read_bool()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if self.include_hidden != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if self.include_hidden != false {
            os.write_bool(2, self.include_hidden)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ReadDir {
        ReadDir::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 20)
    }

    fn default_instance() -> &'static ReadDir {
        static instance: ReadDir = ReadDir {
            path: ::std::string::String::new(),
            include_hidden: false,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ReadDir {
    fn clear(&mut self) {
        self.path.clear();
        self.include_hidden = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadDir {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadDir {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadAllFiles {
    // message fields
    pub id: i32,
    pub path: ::std::string::String,
    pub include_hidden: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadAllFiles {
    fn default() -> &'a ReadAllFiles {
        <ReadAllFiles as ::protobuf::Message>::default_instance()
    }
}

impl ReadAllFiles {
    pub fn new() -> ReadAllFiles {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ReadAllFiles| { &m.id },
            |m: &mut ReadAllFiles| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &ReadAllFiles| { &m.path },
            |m: &mut ReadAllFiles| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_hidden",
            |m: &ReadAllFiles| { &m.include_hidden },
            |m: &mut ReadAllFiles| { &mut m.include_hidden },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadAllFiles>(
            "ReadAllFiles",
            21,
            fields,
        )
    }
}

impl ::protobuf::Message for ReadAllFiles {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.include_hidden = is.read_bool()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if self.include_hidden != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if self.include_hidden != false {
            os.write_bool(3, self.include_hidden)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ReadAllFiles {
        ReadAllFiles::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 21)
    }

    fn default_instance() -> &'static ReadAllFiles {
        static instance: ReadAllFiles = ReadAllFiles {
            id: 0,
            path: ::std::string::String::new(),
            include_hidden: false,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ReadAllFiles {
    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.include_hidden = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadAllFiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadAllFiles {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct FileAction {
    // message oneof groups
    pub union: ::std::option::Option<file_action::Union>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileAction {
    fn default() -> &'a FileAction {
        <FileAction as ::protobuf::Message>::default_instance()
    }
}

impl FileAction {
    pub fn new() -> FileAction {
        ::std::default::Default::default()
    }

    // .hbb.ReadDir read_dir = 1;

    pub fn get_read_dir(&self) -> &ReadDir {
        match self.union {
            ::std::option::Option::Some(file_action::Union::read_dir(ref v)) => v,
            _ => <ReadDir as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_read_dir(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_read_dir(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::read_dir(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_dir(&mut self, v: ReadDir) {
        self.union = ::std::option::Option::Some(file_action::Union::read_dir(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_dir(&mut self) -> &mut ReadDir {
        if let ::std::option::Option::Some(file_action::Union::read_dir(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::read_dir(ReadDir::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::read_dir(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_dir(&mut self) -> ReadDir {
        if self.has_read_dir() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::read_dir(v)) => v,
                _ => panic!(),
            }
        } else {
            ReadDir::new()
        }
    }

    // .hbb.FileTransferSendRequest send = 2;

    pub fn get_send(&self) -> &FileTransferSendRequest {
        match self.union {
            ::std::option::Option::Some(file_action::Union::send(ref v)) => v,
            _ => <FileTransferSendRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_send(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_send(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::send(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_send(&mut self, v: FileTransferSendRequest) {
        self.union = ::std::option::Option::Some(file_action::Union::send(v))
    }

    // Mutable pointer to the field.
    pub fn mut_send(&mut self) -> &mut FileTransferSendRequest {
        if let ::std::option::Option::Some(file_action::Union::send(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::send(FileTransferSendRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::send(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_send(&mut self) -> FileTransferSendRequest {
        if self.has_send() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::send(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferSendRequest::new()
        }
    }

    // .hbb.FileTransferReceiveRequest receive = 3;

    pub fn get_receive(&self) -> &FileTransferReceiveRequest {
        match self.union {
            ::std::option::Option::Some(file_action::Union::receive(ref v)) => v,
            _ => <FileTransferReceiveRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_receive(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_receive(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::receive(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_receive(&mut self, v: FileTransferReceiveRequest) {
        self.union = ::std::option::Option::Some(file_action::Union::receive(v))
    }

    // Mutable pointer to the field.
    pub fn mut_receive(&mut self) -> &mut FileTransferReceiveRequest {
        if let ::std::option::Option::Some(file_action::Union::receive(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::receive(FileTransferReceiveRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::receive(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_receive(&mut self) -> FileTransferReceiveRequest {
        if self.has_receive() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::receive(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferReceiveRequest::new()
        }
    }

    // .hbb.FileDirCreate create = 4;

    pub fn get_create(&self) -> &FileDirCreate {
        match self.union {
            ::std::option::Option::Some(file_action::Union::create(ref v)) => v,
            _ => <FileDirCreate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_create(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_create(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::create(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: FileDirCreate) {
        self.union = ::std::option::Option::Some(file_action::Union::create(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create(&mut self) -> &mut FileDirCreate {
        if let ::std::option::Option::Some(file_action::Union::create(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::create(FileDirCreate::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::create(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create(&mut self) -> FileDirCreate {
        if self.has_create() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::create(v)) => v,
                _ => panic!(),
            }
        } else {
            FileDirCreate::new()
        }
    }

    // .hbb.FileRemoveDir remove_dir = 5;

    pub fn get_remove_dir(&self) -> &FileRemoveDir {
        match self.union {
            ::std::option::Option::Some(file_action::Union::remove_dir(ref v)) => v,
            _ => <FileRemoveDir as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_remove_dir(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_remove_dir(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::remove_dir(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_dir(&mut self, v: FileRemoveDir) {
        self.union = ::std::option::Option::Some(file_action::Union::remove_dir(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_dir(&mut self) -> &mut FileRemoveDir {
        if let ::std::option::Option::Some(file_action::Union::remove_dir(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::remove_dir(FileRemoveDir::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::remove_dir(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_dir(&mut self) -> FileRemoveDir {
        if self.has_remove_dir() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::remove_dir(v)) => v,
                _ => panic!(),
            }
        } else {
            FileRemoveDir::new()
        }
    }

    // .hbb.FileRemoveFile remove_file = 6;

    pub fn get_remove_file(&self) -> &FileRemoveFile {
        match self.union {
            ::std::option::Option::Some(file_action::Union::remove_file(ref v)) => v,
            _ => <FileRemoveFile as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_remove_file(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_remove_file(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::remove_file(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_file(&mut self, v: FileRemoveFile) {
        self.union = ::std::option::Option::Some(file_action::Union::remove_file(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_file(&mut self) -> &mut FileRemoveFile {
        if let ::std::option::Option::Some(file_action::Union::remove_file(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::remove_file(FileRemoveFile::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::remove_file(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_file(&mut self) -> FileRemoveFile {
        if self.has_remove_file() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::remove_file(v)) => v,
                _ => panic!(),
            }
        } else {
            FileRemoveFile::new()
        }
    }

    // .hbb.ReadAllFiles all_files = 7;

    pub fn get_all_files(&self) -> &ReadAllFiles {
        match self.union {
            ::std::option::Option::Some(file_action::Union::all_files(ref v)) => v,
            _ => <ReadAllFiles as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_all_files(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_all_files(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::all_files(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_all_files(&mut self, v: ReadAllFiles) {
        self.union = ::std::option::Option::Some(file_action::Union::all_files(v))
    }

    // Mutable pointer to the field.
    pub fn mut_all_files(&mut self) -> &mut ReadAllFiles {
        if let ::std::option::Option::Some(file_action::Union::all_files(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::all_files(ReadAllFiles::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::all_files(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_all_files(&mut self) -> ReadAllFiles {
        if self.has_all_files() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::all_files(v)) => v,
                _ => panic!(),
            }
        } else {
            ReadAllFiles::new()
        }
    }

    // .hbb.FileTransferCancel cancel = 8;

    pub fn get_cancel(&self) -> &FileTransferCancel {
        match self.union {
            ::std::option::Option::Some(file_action::Union::cancel(ref v)) => v,
            _ => <FileTransferCancel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cancel(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_cancel(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::cancel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cancel(&mut self, v: FileTransferCancel) {
        self.union = ::std::option::Option::Some(file_action::Union::cancel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cancel(&mut self) -> &mut FileTransferCancel {
        if let ::std::option::Option::Some(file_action::Union::cancel(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::cancel(FileTransferCancel::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::cancel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cancel(&mut self) -> FileTransferCancel {
        if self.has_cancel() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::cancel(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferCancel::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ReadDir>(
            "read_dir",
            FileAction::has_read_dir,
            FileAction::get_read_dir,
            FileAction::mut_read_dir,
            FileAction::set_read_dir,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferSendRequest>(
            "send",
            FileAction::has_send,
            FileAction::get_send,
            FileAction::mut_send,
            FileAction::set_send,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferReceiveRequest>(
            "receive",
            FileAction::has_receive,
            FileAction::get_receive,
            FileAction::mut_receive,
            FileAction::set_receive,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileDirCreate>(
            "create",
            FileAction::has_create,
            FileAction::get_create,
            FileAction::mut_create,
            FileAction::set_create,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileRemoveDir>(
            "remove_dir",
            FileAction::has_remove_dir,
            FileAction::get_remove_dir,
            FileAction::mut_remove_dir,
            FileAction::set_remove_dir,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileRemoveFile>(
            "remove_file",
            FileAction::has_remove_file,
            FileAction::get_remove_file,
            FileAction::mut_remove_file,
            FileAction::set_remove_file,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ReadAllFiles>(
            "all_files",
            FileAction::has_all_files,
            FileAction::get_all_files,
            FileAction::mut_all_files,
            FileAction::set_all_files,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferCancel>(
            "cancel",
            FileAction::has_cancel,
            FileAction::get_cancel,
            FileAction::mut_cancel,
            FileAction::set_cancel,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileAction>(
            "FileAction",
            22,
            fields,
        )
    }
}

impl ::protobuf::Message for FileAction {
    fn is_initialized(&self) -> bool {
        if let Some(file_action::Union::read_dir(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(file_action::Union::send(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(file_action::Union::receive(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(file_action::Union::create(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(file_action::Union::remove_dir(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(file_action::Union::remove_file(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(file_action::Union::all_files(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(file_action::Union::cancel(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(file_action::Union::read_dir(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(file_action::Union::send(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(file_action::Union::receive(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(file_action::Union::create(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(file_action::Union::remove_dir(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(file_action::Union::remove_file(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(file_action::Union::all_files(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(file_action::Union::cancel(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_action::Union::read_dir(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &file_action::Union::send(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &file_action::Union::receive(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &file_action::Union::create(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &file_action::Union::remove_dir(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &file_action::Union::remove_file(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &file_action::Union::all_files(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &file_action::Union::cancel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_action::Union::read_dir(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &file_action::Union::send(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &file_action::Union::receive(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &file_action::Union::create(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &file_action::Union::remove_dir(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &file_action::Union::remove_file(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &file_action::Union::all_files(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &file_action::Union::cancel(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FileAction {
        FileAction::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 22)
    }

    fn default_instance() -> &'static FileAction {
        static instance: FileAction = FileAction {
            union: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FileAction {
    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileAction {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FileAction`
pub mod file_action {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Union {
        read_dir(super::ReadDir),
        send(super::FileTransferSendRequest),
        receive(super::FileTransferReceiveRequest),
        create(super::FileDirCreate),
        remove_dir(super::FileRemoveDir),
        remove_file(super::FileRemoveFile),
        all_files(super::ReadAllFiles),
        cancel(super::FileTransferCancel),
    }

    impl ::protobuf::Oneof for Union {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileTransferCancel {
    // message fields
    pub id: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileTransferCancel {
    fn default() -> &'a FileTransferCancel {
        <FileTransferCancel as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferCancel {
    pub fn new() -> FileTransferCancel {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferCancel| { &m.id },
            |m: &mut FileTransferCancel| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferCancel>(
            "FileTransferCancel",
            23,
            fields,
        )
    }
}

impl ::protobuf::Message for FileTransferCancel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = is.read_int32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FileTransferCancel {
        FileTransferCancel::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 23)
    }

    fn default_instance() -> &'static FileTransferCancel {
        static instance: FileTransferCancel = FileTransferCancel {
            id: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FileTransferCancel {
    fn clear(&mut self) {
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileTransferCancel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferCancel {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct FileResponse {
    // message oneof groups
    pub union: ::std::option::Option<file_response::Union>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileResponse {
    fn default() -> &'a FileResponse {
        <FileResponse as ::protobuf::Message>::default_instance()
    }
}

impl FileResponse {
    pub fn new() -> FileResponse {
        ::std::default::Default::default()
    }

    // .hbb.FileDirectory dir = 1;

    pub fn get_dir(&self) -> &FileDirectory {
        match self.union {
            ::std::option::Option::Some(file_response::Union::dir(ref v)) => v,
            _ => <FileDirectory as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_dir(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_dir(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_response::Union::dir(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dir(&mut self, v: FileDirectory) {
        self.union = ::std::option::Option::Some(file_response::Union::dir(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dir(&mut self) -> &mut FileDirectory {
        if let ::std::option::Option::Some(file_response::Union::dir(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_response::Union::dir(FileDirectory::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_response::Union::dir(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dir(&mut self) -> FileDirectory {
        if self.has_dir() {
            match self.union.take() {
                ::std::option::Option::Some(file_response::Union::dir(v)) => v,
                _ => panic!(),
            }
        } else {
            FileDirectory::new()
        }
    }

    // .hbb.FileTransferBlock block = 2;

    pub fn get_block(&self) -> &FileTransferBlock {
        match self.union {
            ::std::option::Option::Some(file_response::Union::block(ref v)) => v,
            _ => <FileTransferBlock as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_block(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_block(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_response::Union::block(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: FileTransferBlock) {
        self.union = ::std::option::Option::Some(file_response::Union::block(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block(&mut self) -> &mut FileTransferBlock {
        if let ::std::option::Option::Some(file_response::Union::block(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_response::Union::block(FileTransferBlock::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_response::Union::block(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block(&mut self) -> FileTransferBlock {
        if self.has_block() {
            match self.union.take() {
                ::std::option::Option::Some(file_response::Union::block(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferBlock::new()
        }
    }

    // .hbb.FileTransferError error = 3;

    pub fn get_error(&self) -> &FileTransferError {
        match self.union {
            ::std::option::Option::Some(file_response::Union::error(ref v)) => v,
            _ => <FileTransferError as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_error(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_response::Union::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: FileTransferError) {
        self.union = ::std::option::Option::Some(file_response::Union::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut FileTransferError {
        if let ::std::option::Option::Some(file_response::Union::error(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_response::Union::error(FileTransferError::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_response::Union::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> FileTransferError {
        if self.has_error() {
            match self.union.take() {
                ::std::option::Option::Some(file_response::Union::error(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferError::new()
        }
    }

    // .hbb.FileTransferDone done = 4;

    pub fn get_done(&self) -> &FileTransferDone {
        match self.union {
            ::std::option::Option::Some(file_response::Union::done(ref v)) => v,
            _ => <FileTransferDone as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_done(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_done(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_response::Union::done(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_done(&mut self, v: FileTransferDone) {
        self.union = ::std::option::Option::Some(file_response::Union::done(v))
    }

    // Mutable pointer to the field.
    pub fn mut_done(&mut self) -> &mut FileTransferDone {
        if let ::std::option::Option::Some(file_response::Union::done(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_response::Union::done(FileTransferDone::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_response::Union::done(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_done(&mut self) -> FileTransferDone {
        if self.has_done() {
            match self.union.take() {
                ::std::option::Option::Some(file_response::Union::done(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferDone::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileDirectory>(
            "dir",
            FileResponse::has_dir,
            FileResponse::get_dir,
            FileResponse::mut_dir,
            FileResponse::set_dir,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferBlock>(
            "block",
            FileResponse::has_block,
            FileResponse::get_block,
            FileResponse::mut_block,
            FileResponse::set_block,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferError>(
            "error",
            FileResponse::has_error,
            FileResponse::get_error,
            FileResponse::mut_error,
            FileResponse::set_error,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferDone>(
            "done",
            FileResponse::has_done,
            FileResponse::get_done,
            FileResponse::mut_done,
            FileResponse::set_done,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileResponse>(
            "FileResponse",
            24,
            fields,
        )
    }
}

impl ::protobuf::Message for FileResponse {
    fn is_initialized(&self) -> bool {
        if let Some(file_response::Union::dir(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(file_response::Union::block(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(file_response::Union::error(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(file_response::Union::done(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(file_response::Union::dir(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(file_response::Union::block(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(file_response::Union::error(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(file_response::Union::done(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_response::Union::dir(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &file_response::Union::block(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &file_response::Union::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &file_response::Union::done(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_response::Union::dir(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &file_response::Union::block(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &file_response::Union::error(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &file_response::Union::done(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FileResponse {
        FileResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 24)
    }

    fn default_instance() -> &'static FileResponse {
        static instance: FileResponse = FileResponse {
            union: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FileResponse {
    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FileResponse`
pub mod file_response {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Union {
        dir(super::FileDirectory),
        block(super::FileTransferBlock),
        error(super::FileTransferError),
        done(super::FileTransferDone),
    }

    impl ::protobuf::Oneof for Union {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileTransferBlock {
    // message fields
    pub id: i32,
    pub file_num: i32,
    pub data: ::std::vec::Vec<u8>,
    pub compressed: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileTransferBlock {
    fn default() -> &'a FileTransferBlock {
        <FileTransferBlock as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferBlock {
    pub fn new() -> FileTransferBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferBlock| { &m.id },
            |m: &mut FileTransferBlock| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferBlock| { &m.file_num },
            |m: &mut FileTransferBlock| { &mut m.file_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &FileTransferBlock| { &m.data },
            |m: &mut FileTransferBlock| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compressed",
            |m: &FileTransferBlock| { &m.compressed },
            |m: &mut FileTransferBlock| { &mut m.compressed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferBlock>(
            "FileTransferBlock",
            25,
            fields,
        )
    }
}

impl ::protobuf::Message for FileTransferBlock {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_num = is.read_sint32()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = is.read_bytes()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.compressed = is.read_bool()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.file_num);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        if self.compressed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.file_num != 0 {
            os.write_sint32(2, self.file_num)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        if self.compressed != false {
            os.write_bool(4, self.compressed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FileTransferBlock {
        FileTransferBlock::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 25)
    }

    fn default_instance() -> &'static FileTransferBlock {
        static instance: FileTransferBlock = FileTransferBlock {
            id: 0,
            file_num: 0,
            data: ::std::vec::Vec::new(),
            compressed: false,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FileTransferBlock {
    fn clear(&mut self) {
        self.id = 0;
        self.file_num = 0;
        self.data.clear();
        self.compressed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileTransferBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferBlock {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct FileTransferError {
    // message fields
    pub id: i32,
    pub error: ::std::string::String,
    pub file_num: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileTransferError {
    fn default() -> &'a FileTransferError {
        <FileTransferError as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferError {
    pub fn new() -> FileTransferError {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferError| { &m.id },
            |m: &mut FileTransferError| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &FileTransferError| { &m.error },
            |m: &mut FileTransferError| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferError| { &m.file_num },
            |m: &mut FileTransferError| { &mut m.file_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferError>(
            "FileTransferError",
            26,
            fields,
        )
    }
}

impl ::protobuf::Message for FileTransferError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_num = is.read_sint32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.file_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if self.file_num != 0 {
            os.write_sint32(3, self.file_num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FileTransferError {
        FileTransferError::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 26)
    }

    fn default_instance() -> &'static FileTransferError {
        static instance: FileTransferError = FileTransferError {
            id: 0,
            error: ::std::string::String::new(),
            file_num: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FileTransferError {
    fn clear(&mut self) {
        self.id = 0;
        self.error.clear();
        self.file_num = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileTransferError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferError {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct FileTransferSendRequest {
    // message fields
    pub id: i32,
    pub path: ::std::string::String,
    pub include_hidden: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileTransferSendRequest {
    fn default() -> &'a FileTransferSendRequest {
        <FileTransferSendRequest as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferSendRequest {
    pub fn new() -> FileTransferSendRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferSendRequest| { &m.id },
            |m: &mut FileTransferSendRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileTransferSendRequest| { &m.path },
            |m: &mut FileTransferSendRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_hidden",
            |m: &FileTransferSendRequest| { &m.include_hidden },
            |m: &mut FileTransferSendRequest| { &mut m.include_hidden },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferSendRequest>(
            "FileTransferSendRequest",
            27,
            fields,
        )
    }
}

impl ::protobuf::Message for FileTransferSendRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.include_hidden = is.read_bool()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if self.include_hidden != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if self.include_hidden != false {
            os.write_bool(3, self.include_hidden)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FileTransferSendRequest {
        FileTransferSendRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 27)
    }

    fn default_instance() -> &'static FileTransferSendRequest {
        static instance: FileTransferSendRequest = FileTransferSendRequest {
            id: 0,
            path: ::std::string::String::new(),
            include_hidden: false,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FileTransferSendRequest {
    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.include_hidden = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileTransferSendRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferSendRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct FileTransferDone {
    // message fields
    pub id: i32,
    pub file_num: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileTransferDone {
    fn default() -> &'a FileTransferDone {
        <FileTransferDone as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferDone {
    pub fn new() -> FileTransferDone {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferDone| { &m.id },
            |m: &mut FileTransferDone| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferDone| { &m.file_num },
            |m: &mut FileTransferDone| { &mut m.file_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferDone>(
            "FileTransferDone",
            28,
            fields,
        )
    }
}

impl ::protobuf::Message for FileTransferDone {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_num = is.read_sint32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.file_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.file_num != 0 {
            os.write_sint32(2, self.file_num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FileTransferDone {
        FileTransferDone::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 28)
    }

    fn default_instance() -> &'static FileTransferDone {
        static instance: FileTransferDone = FileTransferDone {
            id: 0,
            file_num: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FileTransferDone {
    fn clear(&mut self) {
        self.id = 0;
        self.file_num = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileTransferDone {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferDone {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct FileTransferReceiveRequest {
    // message fields
    pub id: i32,
    pub path: ::std::string::String,
    pub files: ::std::vec::Vec<FileEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileTransferReceiveRequest {
    fn default() -> &'a FileTransferReceiveRequest {
        <FileTransferReceiveRequest as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferReceiveRequest {
    pub fn new() -> FileTransferReceiveRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferReceiveRequest| { &m.id },
            |m: &mut FileTransferReceiveRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileTransferReceiveRequest| { &m.path },
            |m: &mut FileTransferReceiveRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &FileTransferReceiveRequest| { &m.files },
            |m: &mut FileTransferReceiveRequest| { &mut m.files },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferReceiveRequest>(
            "FileTransferReceiveRequest",
            29,
            fields,
        )
    }
}

impl ::protobuf::Message for FileTransferReceiveRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path = is.read_string()?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.files)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        for v in &self.files {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FileTransferReceiveRequest {
        FileTransferReceiveRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 29)
    }

    fn default_instance() -> &'static FileTransferReceiveRequest {
        static instance: FileTransferReceiveRequest = FileTransferReceiveRequest {
            id: 0,
            path: ::std::string::String::new(),
            files: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FileTransferReceiveRequest {
    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.files.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileTransferReceiveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferReceiveRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct FileRemoveDir {
    // message fields
    pub id: i32,
    pub path: ::std::string::String,
    pub recursive: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileRemoveDir {
    fn default() -> &'a FileRemoveDir {
        <FileRemoveDir as ::protobuf::Message>::default_instance()
    }
}

impl FileRemoveDir {
    pub fn new() -> FileRemoveDir {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileRemoveDir| { &m.id },
            |m: &mut FileRemoveDir| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileRemoveDir| { &m.path },
            |m: &mut FileRemoveDir| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recursive",
            |m: &FileRemoveDir| { &m.recursive },
            |m: &mut FileRemoveDir| { &mut m.recursive },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileRemoveDir>(
            "FileRemoveDir",
            30,
            fields,
        )
    }
}

impl ::protobuf::Message for FileRemoveDir {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.recursive = is.read_bool()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if self.recursive != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if self.recursive != false {
            os.write_bool(3, self.recursive)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FileRemoveDir {
        FileRemoveDir::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 30)
    }

    fn default_instance() -> &'static FileRemoveDir {
        static instance: FileRemoveDir = FileRemoveDir {
            id: 0,
            path: ::std::string::String::new(),
            recursive: false,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FileRemoveDir {
    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.recursive = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileRemoveDir {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileRemoveDir {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct FileRemoveFile {
    // message fields
    pub id: i32,
    pub path: ::std::string::String,
    pub file_num: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileRemoveFile {
    fn default() -> &'a FileRemoveFile {
        <FileRemoveFile as ::protobuf::Message>::default_instance()
    }
}

impl FileRemoveFile {
    pub fn new() -> FileRemoveFile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileRemoveFile| { &m.id },
            |m: &mut FileRemoveFile| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileRemoveFile| { &m.path },
            |m: &mut FileRemoveFile| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileRemoveFile| { &m.file_num },
            |m: &mut FileRemoveFile| { &mut m.file_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileRemoveFile>(
            "FileRemoveFile",
            31,
            fields,
        )
    }
}

impl ::protobuf::Message for FileRemoveFile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_num = is.read_sint32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.file_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if self.file_num != 0 {
            os.write_sint32(3, self.file_num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FileRemoveFile {
        FileRemoveFile::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 31)
    }

    fn default_instance() -> &'static FileRemoveFile {
        static instance: FileRemoveFile = FileRemoveFile {
            id: 0,
            path: ::std::string::String::new(),
            file_num: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FileRemoveFile {
    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.file_num = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileRemoveFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileRemoveFile {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct FileDirCreate {
    // message fields
    pub id: i32,
    pub path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileDirCreate {
    fn default() -> &'a FileDirCreate {
        <FileDirCreate as ::protobuf::Message>::default_instance()
    }
}

impl FileDirCreate {
    pub fn new() -> FileDirCreate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileDirCreate| { &m.id },
            |m: &mut FileDirCreate| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileDirCreate| { &m.path },
            |m: &mut FileDirCreate| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileDirCreate>(
            "FileDirCreate",
            32,
            fields,
        )
    }
}

impl ::protobuf::Message for FileDirCreate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FileDirCreate {
        FileDirCreate::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 32)
    }

    fn default_instance() -> &'static FileDirCreate {
        static instance: FileDirCreate = FileDirCreate {
            id: 0,
            path: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FileDirCreate {
    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileDirCreate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileDirCreate {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct SwitchDisplay {
    // message fields
    pub display: i32,
    pub x: i32,
    pub y: i32,
    pub width: i32,
    pub height: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwitchDisplay {
    fn default() -> &'a SwitchDisplay {
        <SwitchDisplay as ::protobuf::Message>::default_instance()
    }
}

impl SwitchDisplay {
    pub fn new() -> SwitchDisplay {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "display",
            |m: &SwitchDisplay| { &m.display },
            |m: &mut SwitchDisplay| { &mut m.display },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &SwitchDisplay| { &m.x },
            |m: &mut SwitchDisplay| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &SwitchDisplay| { &m.y },
            |m: &mut SwitchDisplay| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &SwitchDisplay| { &m.width },
            |m: &mut SwitchDisplay| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &SwitchDisplay| { &m.height },
            |m: &mut SwitchDisplay| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwitchDisplay>(
            "SwitchDisplay",
            33,
            fields,
        )
    }
}

impl ::protobuf::Message for SwitchDisplay {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.display = is.read_int32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x = is.read_sint32()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.y = is.read_sint32()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.width = is.read_int32()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.height = is.read_int32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.display != 0 {
            my_size += ::protobuf::rt::value_size(1, self.display, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.x != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.y);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::value_size(4, self.width, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(5, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.display != 0 {
            os.write_int32(1, self.display)?;
        }
        if self.x != 0 {
            os.write_sint32(2, self.x)?;
        }
        if self.y != 0 {
            os.write_sint32(3, self.y)?;
        }
        if self.width != 0 {
            os.write_int32(4, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(5, self.height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> SwitchDisplay {
        SwitchDisplay::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 33)
    }

    fn default_instance() -> &'static SwitchDisplay {
        static instance: SwitchDisplay = SwitchDisplay {
            display: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for SwitchDisplay {
    fn clear(&mut self) {
        self.display = 0;
        self.x = 0;
        self.y = 0;
        self.width = 0;
        self.height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SwitchDisplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchDisplay {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PermissionInfo {
    // message fields
    pub permission: ::protobuf::ProtobufEnumOrUnknown<Permission>,
    pub enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PermissionInfo {
    fn default() -> &'a PermissionInfo {
        <PermissionInfo as ::protobuf::Message>::default_instance()
    }
}

impl PermissionInfo {
    pub fn new() -> PermissionInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "permission",
            |m: &PermissionInfo| { &m.permission },
            |m: &mut PermissionInfo| { &mut m.permission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enabled",
            |m: &PermissionInfo| { &m.enabled },
            |m: &mut PermissionInfo| { &mut m.enabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermissionInfo>(
            "PermissionInfo",
            34,
            fields,
        )
    }
}

impl ::protobuf::Message for PermissionInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.permission = is.read_enum_or_unknown()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enabled = is.read_bool()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.permission != ::protobuf::ProtobufEnumOrUnknown::new(Permission::Keyboard) {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, self.permission);
        }
        if self.enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.permission != ::protobuf::ProtobufEnumOrUnknown::new(Permission::Keyboard) {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&self.permission))?;
        }
        if self.enabled != false {
            os.write_bool(2, self.enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PermissionInfo {
        PermissionInfo::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 34)
    }

    fn default_instance() -> &'static PermissionInfo {
        static instance: PermissionInfo = PermissionInfo {
            permission: ::protobuf::ProtobufEnumOrUnknown::from_i32(1),
            enabled: false,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PermissionInfo {
    fn clear(&mut self) {
        self.permission = ::protobuf::ProtobufEnumOrUnknown::new(Permission::Keyboard);
        self.enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PermissionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionInfo {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct OptionMessage {
    // message fields
    pub image_quality: ::protobuf::ProtobufEnumOrUnknown<ImageQuality>,
    pub lock_after_session_end: ::protobuf::ProtobufEnumOrUnknown<BoolOption>,
    pub show_remote_cursor: ::protobuf::ProtobufEnumOrUnknown<BoolOption>,
    pub privacy_mode: ::protobuf::ProtobufEnumOrUnknown<BoolOption>,
    pub block_input: ::protobuf::ProtobufEnumOrUnknown<BoolOption>,
    pub custom_image_quality: i32,
    pub disable_audio: ::protobuf::ProtobufEnumOrUnknown<BoolOption>,
    pub disable_clipboard: ::protobuf::ProtobufEnumOrUnknown<BoolOption>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a OptionMessage {
    fn default() -> &'a OptionMessage {
        <OptionMessage as ::protobuf::Message>::default_instance()
    }
}

impl OptionMessage {
    pub fn new() -> OptionMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "image_quality",
            |m: &OptionMessage| { &m.image_quality },
            |m: &mut OptionMessage| { &mut m.image_quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lock_after_session_end",
            |m: &OptionMessage| { &m.lock_after_session_end },
            |m: &mut OptionMessage| { &mut m.lock_after_session_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "show_remote_cursor",
            |m: &OptionMessage| { &m.show_remote_cursor },
            |m: &mut OptionMessage| { &mut m.show_remote_cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "privacy_mode",
            |m: &OptionMessage| { &m.privacy_mode },
            |m: &mut OptionMessage| { &mut m.privacy_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_input",
            |m: &OptionMessage| { &m.block_input },
            |m: &mut OptionMessage| { &mut m.block_input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "custom_image_quality",
            |m: &OptionMessage| { &m.custom_image_quality },
            |m: &mut OptionMessage| { &mut m.custom_image_quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disable_audio",
            |m: &OptionMessage| { &m.disable_audio },
            |m: &mut OptionMessage| { &mut m.disable_audio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disable_clipboard",
            |m: &OptionMessage| { &m.disable_clipboard },
            |m: &mut OptionMessage| { &mut m.disable_clipboard },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OptionMessage>(
            "OptionMessage",
            35,
            fields,
        )
    }
}

impl ::protobuf::Message for OptionMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.image_quality = is.read_enum_or_unknown()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lock_after_session_end = is.read_enum_or_unknown()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.show_remote_cursor = is.read_enum_or_unknown()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.privacy_mode = is.read_enum_or_unknown()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.block_input = is.read_enum_or_unknown()?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.custom_image_quality = is.read_int32()?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.disable_audio = is.read_enum_or_unknown()?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.disable_clipboard = is.read_enum_or_unknown()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.image_quality != ::protobuf::ProtobufEnumOrUnknown::new(ImageQuality::NotSet) {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, self.image_quality);
        }
        if self.lock_after_session_end != ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet) {
            my_size += ::protobuf::rt::enum_or_unknown_size(2, self.lock_after_session_end);
        }
        if self.show_remote_cursor != ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet) {
            my_size += ::protobuf::rt::enum_or_unknown_size(3, self.show_remote_cursor);
        }
        if self.privacy_mode != ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet) {
            my_size += ::protobuf::rt::enum_or_unknown_size(4, self.privacy_mode);
        }
        if self.block_input != ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet) {
            my_size += ::protobuf::rt::enum_or_unknown_size(5, self.block_input);
        }
        if self.custom_image_quality != 0 {
            my_size += ::protobuf::rt::value_size(6, self.custom_image_quality, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.disable_audio != ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet) {
            my_size += ::protobuf::rt::enum_or_unknown_size(7, self.disable_audio);
        }
        if self.disable_clipboard != ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet) {
            my_size += ::protobuf::rt::enum_or_unknown_size(8, self.disable_clipboard);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.image_quality != ::protobuf::ProtobufEnumOrUnknown::new(ImageQuality::NotSet) {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&self.image_quality))?;
        }
        if self.lock_after_session_end != ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet) {
            os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(&self.lock_after_session_end))?;
        }
        if self.show_remote_cursor != ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet) {
            os.write_enum(3, ::protobuf::ProtobufEnumOrUnknown::value(&self.show_remote_cursor))?;
        }
        if self.privacy_mode != ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet) {
            os.write_enum(4, ::protobuf::ProtobufEnumOrUnknown::value(&self.privacy_mode))?;
        }
        if self.block_input != ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet) {
            os.write_enum(5, ::protobuf::ProtobufEnumOrUnknown::value(&self.block_input))?;
        }
        if self.custom_image_quality != 0 {
            os.write_int32(6, self.custom_image_quality)?;
        }
        if self.disable_audio != ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet) {
            os.write_enum(7, ::protobuf::ProtobufEnumOrUnknown::value(&self.disable_audio))?;
        }
        if self.disable_clipboard != ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet) {
            os.write_enum(8, ::protobuf::ProtobufEnumOrUnknown::value(&self.disable_clipboard))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> OptionMessage {
        OptionMessage::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 35)
    }

    fn default_instance() -> &'static OptionMessage {
        static instance: OptionMessage = OptionMessage {
            image_quality: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            lock_after_session_end: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            show_remote_cursor: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            privacy_mode: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            block_input: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            custom_image_quality: 0,
            disable_audio: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            disable_clipboard: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for OptionMessage {
    fn clear(&mut self) {
        self.image_quality = ::protobuf::ProtobufEnumOrUnknown::new(ImageQuality::NotSet);
        self.lock_after_session_end = ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet);
        self.show_remote_cursor = ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet);
        self.privacy_mode = ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet);
        self.block_input = ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet);
        self.custom_image_quality = 0;
        self.disable_audio = ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet);
        self.disable_clipboard = ::protobuf::ProtobufEnumOrUnknown::new(BoolOption::NotSet);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OptionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OptionMessage {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct TestDelay {
    // message fields
    pub time: i64,
    pub from_client: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a TestDelay {
    fn default() -> &'a TestDelay {
        <TestDelay as ::protobuf::Message>::default_instance()
    }
}

impl TestDelay {
    pub fn new() -> TestDelay {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time",
            |m: &TestDelay| { &m.time },
            |m: &mut TestDelay| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "from_client",
            |m: &TestDelay| { &m.from_client },
            |m: &mut TestDelay| { &mut m.from_client },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestDelay>(
            "TestDelay",
            36,
            fields,
        )
    }
}

impl ::protobuf::Message for TestDelay {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time = is.read_int64()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.from_client = is.read_bool()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time != 0 {
            my_size += ::protobuf::rt::value_size(1, self.time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.from_client != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.time != 0 {
            os.write_int64(1, self.time)?;
        }
        if self.from_client != false {
            os.write_bool(2, self.from_client)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> TestDelay {
        TestDelay::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 36)
    }

    fn default_instance() -> &'static TestDelay {
        static instance: TestDelay = TestDelay {
            time: 0,
            from_client: false,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for TestDelay {
    fn clear(&mut self) {
        self.time = 0;
        self.from_client = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestDelay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestDelay {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct PublicKey {
    // message fields
    pub asymmetric_value: ::std::vec::Vec<u8>,
    pub symmetric_value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublicKey {
    fn default() -> &'a PublicKey {
        <PublicKey as ::protobuf::Message>::default_instance()
    }
}

impl PublicKey {
    pub fn new() -> PublicKey {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "asymmetric_value",
            |m: &PublicKey| { &m.asymmetric_value },
            |m: &mut PublicKey| { &mut m.asymmetric_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "symmetric_value",
            |m: &PublicKey| { &m.symmetric_value },
            |m: &mut PublicKey| { &mut m.symmetric_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublicKey>(
            "PublicKey",
            37,
            fields,
        )
    }
}

impl ::protobuf::Message for PublicKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.asymmetric_value = is.read_bytes()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.symmetric_value = is.read_bytes()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.asymmetric_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.asymmetric_value);
        }
        if !self.symmetric_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.symmetric_value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.asymmetric_value.is_empty() {
            os.write_bytes(1, &self.asymmetric_value)?;
        }
        if !self.symmetric_value.is_empty() {
            os.write_bytes(2, &self.symmetric_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PublicKey {
        PublicKey::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 37)
    }

    fn default_instance() -> &'static PublicKey {
        static instance: PublicKey = PublicKey {
            asymmetric_value: ::std::vec::Vec::new(),
            symmetric_value: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PublicKey {
    fn clear(&mut self) {
        self.asymmetric_value.clear();
        self.symmetric_value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicKey {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct SignedId {
    // message fields
    pub id: ::std::vec::Vec<u8>,
    pub pk: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignedId {
    fn default() -> &'a SignedId {
        <SignedId as ::protobuf::Message>::default_instance()
    }
}

impl SignedId {
    pub fn new() -> SignedId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &SignedId| { &m.id },
            |m: &mut SignedId| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pk",
            |m: &SignedId| { &m.pk },
            |m: &mut SignedId| { &mut m.pk },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignedId>(
            "SignedId",
            38,
            fields,
        )
    }
}

impl ::protobuf::Message for SignedId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = is.read_bytes()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pk = is.read_bytes()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if !self.pk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.pk);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if !self.pk.is_empty() {
            os.write_bytes(2, &self.pk)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> SignedId {
        SignedId::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 38)
    }

    fn default_instance() -> &'static SignedId {
        static instance: SignedId = SignedId {
            id: ::std::vec::Vec::new(),
            pk: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for SignedId {
    fn clear(&mut self) {
        self.id.clear();
        self.pk.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignedId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedId {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct AudioFormat {
    // message fields
    pub sample_rate: u32,
    pub channels: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a AudioFormat {
    fn default() -> &'a AudioFormat {
        <AudioFormat as ::protobuf::Message>::default_instance()
    }
}

impl AudioFormat {
    pub fn new() -> AudioFormat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_rate",
            |m: &AudioFormat| { &m.sample_rate },
            |m: &mut AudioFormat| { &mut m.sample_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channels",
            |m: &AudioFormat| { &m.channels },
            |m: &mut AudioFormat| { &mut m.channels },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioFormat>(
            "AudioFormat",
            39,
            fields,
        )
    }
}

impl ::protobuf::Message for AudioFormat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sample_rate = is.read_uint32()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.channels = is.read_uint32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.sample_rate != 0 {
            my_size += ::protobuf::rt::value_size(1, self.sample_rate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.channels != 0 {
            my_size += ::protobuf::rt::value_size(2, self.channels, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.sample_rate != 0 {
            os.write_uint32(1, self.sample_rate)?;
        }
        if self.channels != 0 {
            os.write_uint32(2, self.channels)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> AudioFormat {
        AudioFormat::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 39)
    }

    fn default_instance() -> &'static AudioFormat {
        static instance: AudioFormat = AudioFormat {
            sample_rate: 0,
            channels: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for AudioFormat {
    fn clear(&mut self) {
        self.sample_rate = 0;
        self.channels = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AudioFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioFormat {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct AudioFrame {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a AudioFrame {
    fn default() -> &'a AudioFrame {
        <AudioFrame as ::protobuf::Message>::default_instance()
    }
}

impl AudioFrame {
    pub fn new() -> AudioFrame {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &AudioFrame| { &m.data },
            |m: &mut AudioFrame| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioFrame>(
            "AudioFrame",
            40,
            fields,
        )
    }
}

impl ::protobuf::Message for AudioFrame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = is.read_bytes()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> AudioFrame {
        AudioFrame::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 40)
    }

    fn default_instance() -> &'static AudioFrame {
        static instance: AudioFrame = AudioFrame {
            data: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for AudioFrame {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AudioFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioFrame {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Misc {
    // message oneof groups
    pub union: ::std::option::Option<misc::Union>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Misc {
    fn default() -> &'a Misc {
        <Misc as ::protobuf::Message>::default_instance()
    }
}

impl Misc {
    pub fn new() -> Misc {
        ::std::default::Default::default()
    }

    // .hbb.ChatMessage chat_message = 4;

    pub fn get_chat_message(&self) -> &ChatMessage {
        match self.union {
            ::std::option::Option::Some(misc::Union::chat_message(ref v)) => v,
            _ => <ChatMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_chat_message(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_chat_message(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::chat_message(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chat_message(&mut self, v: ChatMessage) {
        self.union = ::std::option::Option::Some(misc::Union::chat_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chat_message(&mut self) -> &mut ChatMessage {
        if let ::std::option::Option::Some(misc::Union::chat_message(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::chat_message(ChatMessage::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::chat_message(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chat_message(&mut self) -> ChatMessage {
        if self.has_chat_message() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::chat_message(v)) => v,
                _ => panic!(),
            }
        } else {
            ChatMessage::new()
        }
    }

    // .hbb.SwitchDisplay switch_display = 5;

    pub fn get_switch_display(&self) -> &SwitchDisplay {
        match self.union {
            ::std::option::Option::Some(misc::Union::switch_display(ref v)) => v,
            _ => <SwitchDisplay as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_switch_display(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_switch_display(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::switch_display(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_switch_display(&mut self, v: SwitchDisplay) {
        self.union = ::std::option::Option::Some(misc::Union::switch_display(v))
    }

    // Mutable pointer to the field.
    pub fn mut_switch_display(&mut self) -> &mut SwitchDisplay {
        if let ::std::option::Option::Some(misc::Union::switch_display(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::switch_display(SwitchDisplay::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::switch_display(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_switch_display(&mut self) -> SwitchDisplay {
        if self.has_switch_display() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::switch_display(v)) => v,
                _ => panic!(),
            }
        } else {
            SwitchDisplay::new()
        }
    }

    // .hbb.PermissionInfo permission_info = 6;

    pub fn get_permission_info(&self) -> &PermissionInfo {
        match self.union {
            ::std::option::Option::Some(misc::Union::permission_info(ref v)) => v,
            _ => <PermissionInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_permission_info(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_permission_info(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::permission_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_permission_info(&mut self, v: PermissionInfo) {
        self.union = ::std::option::Option::Some(misc::Union::permission_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_permission_info(&mut self) -> &mut PermissionInfo {
        if let ::std::option::Option::Some(misc::Union::permission_info(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::permission_info(PermissionInfo::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::permission_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_permission_info(&mut self) -> PermissionInfo {
        if self.has_permission_info() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::permission_info(v)) => v,
                _ => panic!(),
            }
        } else {
            PermissionInfo::new()
        }
    }

    // .hbb.OptionMessage option = 7;

    pub fn get_option(&self) -> &OptionMessage {
        match self.union {
            ::std::option::Option::Some(misc::Union::option(ref v)) => v,
            _ => <OptionMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_option(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_option(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::option(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_option(&mut self, v: OptionMessage) {
        self.union = ::std::option::Option::Some(misc::Union::option(v))
    }

    // Mutable pointer to the field.
    pub fn mut_option(&mut self) -> &mut OptionMessage {
        if let ::std::option::Option::Some(misc::Union::option(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::option(OptionMessage::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::option(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_option(&mut self) -> OptionMessage {
        if self.has_option() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::option(v)) => v,
                _ => panic!(),
            }
        } else {
            OptionMessage::new()
        }
    }

    // .hbb.AudioFormat audio_format = 8;

    pub fn get_audio_format(&self) -> &AudioFormat {
        match self.union {
            ::std::option::Option::Some(misc::Union::audio_format(ref v)) => v,
            _ => <AudioFormat as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_audio_format(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_audio_format(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::audio_format(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_audio_format(&mut self, v: AudioFormat) {
        self.union = ::std::option::Option::Some(misc::Union::audio_format(v))
    }

    // Mutable pointer to the field.
    pub fn mut_audio_format(&mut self) -> &mut AudioFormat {
        if let ::std::option::Option::Some(misc::Union::audio_format(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::audio_format(AudioFormat::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::audio_format(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_audio_format(&mut self) -> AudioFormat {
        if self.has_audio_format() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::audio_format(v)) => v,
                _ => panic!(),
            }
        } else {
            AudioFormat::new()
        }
    }

    // string close_reason = 9;

    pub fn get_close_reason(&self) -> &str {
        match self.union {
            ::std::option::Option::Some(misc::Union::close_reason(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_close_reason(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_close_reason(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::close_reason(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_close_reason(&mut self, v: ::std::string::String) {
        self.union = ::std::option::Option::Some(misc::Union::close_reason(v))
    }

    // Mutable pointer to the field.
    pub fn mut_close_reason(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(misc::Union::close_reason(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::close_reason(::std::string::String::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::close_reason(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_close_reason(&mut self) -> ::std::string::String {
        if self.has_close_reason() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::close_reason(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bool refresh_video = 10;

    pub fn get_refresh_video(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::refresh_video(v)) => v,
            _ => false,
        }
    }

    pub fn clear_refresh_video(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_refresh_video(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::refresh_video(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_refresh_video(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::refresh_video(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ChatMessage>(
            "chat_message",
            Misc::has_chat_message,
            Misc::get_chat_message,
            Misc::mut_chat_message,
            Misc::set_chat_message,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SwitchDisplay>(
            "switch_display",
            Misc::has_switch_display,
            Misc::get_switch_display,
            Misc::mut_switch_display,
            Misc::set_switch_display,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PermissionInfo>(
            "permission_info",
            Misc::has_permission_info,
            Misc::get_permission_info,
            Misc::mut_permission_info,
            Misc::set_permission_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OptionMessage>(
            "option",
            Misc::has_option,
            Misc::get_option,
            Misc::mut_option,
            Misc::set_option,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AudioFormat>(
            "audio_format",
            Misc::has_audio_format,
            Misc::get_audio_format,
            Misc::mut_audio_format,
            Misc::set_audio_format,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "close_reason",
            Misc::has_close_reason,
            Misc::get_close_reason,
            Misc::set_close_reason,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "refresh_video",
            Misc::has_refresh_video,
            Misc::get_refresh_video,
            Misc::set_refresh_video,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Misc>(
            "Misc",
            41,
            fields,
        )
    }
}

impl ::protobuf::Message for Misc {
    fn is_initialized(&self) -> bool {
        if let Some(misc::Union::chat_message(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(misc::Union::switch_display(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(misc::Union::permission_info(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(misc::Union::option(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(misc::Union::audio_format(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(misc::Union::chat_message(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(misc::Union::switch_display(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(misc::Union::permission_info(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(misc::Union::option(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(misc::Union::audio_format(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(misc::Union::close_reason(is.read_string()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(misc::Union::refresh_video(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &misc::Union::chat_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &misc::Union::switch_display(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &misc::Union::permission_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &misc::Union::option(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &misc::Union::audio_format(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &misc::Union::close_reason(ref v) => {
                    my_size += ::protobuf::rt::string_size(9, &v);
                },
                &misc::Union::refresh_video(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &misc::Union::chat_message(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &misc::Union::switch_display(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &misc::Union::permission_info(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &misc::Union::option(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &misc::Union::audio_format(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &misc::Union::close_reason(ref v) => {
                    os.write_string(9, v)?;
                },
                &misc::Union::refresh_video(v) => {
                    os.write_bool(10, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Misc {
        Misc::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 41)
    }

    fn default_instance() -> &'static Misc {
        static instance: Misc = Misc {
            union: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Misc {
    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Misc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Misc {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Misc`
pub mod misc {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Union {
        chat_message(super::ChatMessage),
        switch_display(super::SwitchDisplay),
        permission_info(super::PermissionInfo),
        option(super::OptionMessage),
        audio_format(super::AudioFormat),
        close_reason(::std::string::String),
        refresh_video(bool),
    }

    impl ::protobuf::Oneof for Union {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Message {
    // message oneof groups
    pub union: ::std::option::Option<message::Union>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // .hbb.SignedId signed_id = 3;

    pub fn get_signed_id(&self) -> &SignedId {
        match self.union {
            ::std::option::Option::Some(message::Union::signed_id(ref v)) => v,
            _ => <SignedId as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_signed_id(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_signed_id(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::signed_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_id(&mut self, v: SignedId) {
        self.union = ::std::option::Option::Some(message::Union::signed_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_id(&mut self) -> &mut SignedId {
        if let ::std::option::Option::Some(message::Union::signed_id(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::signed_id(SignedId::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::signed_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_id(&mut self) -> SignedId {
        if self.has_signed_id() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::signed_id(v)) => v,
                _ => panic!(),
            }
        } else {
            SignedId::new()
        }
    }

    // .hbb.PublicKey public_key = 4;

    pub fn get_public_key(&self) -> &PublicKey {
        match self.union {
            ::std::option::Option::Some(message::Union::public_key(ref v)) => v,
            _ => <PublicKey as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_public_key(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_public_key(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::public_key(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: PublicKey) {
        self.union = ::std::option::Option::Some(message::Union::public_key(v))
    }

    // Mutable pointer to the field.
    pub fn mut_public_key(&mut self) -> &mut PublicKey {
        if let ::std::option::Option::Some(message::Union::public_key(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::public_key(PublicKey::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::public_key(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_public_key(&mut self) -> PublicKey {
        if self.has_public_key() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::public_key(v)) => v,
                _ => panic!(),
            }
        } else {
            PublicKey::new()
        }
    }

    // .hbb.TestDelay test_delay = 5;

    pub fn get_test_delay(&self) -> &TestDelay {
        match self.union {
            ::std::option::Option::Some(message::Union::test_delay(ref v)) => v,
            _ => <TestDelay as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_test_delay(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_test_delay(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::test_delay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_test_delay(&mut self, v: TestDelay) {
        self.union = ::std::option::Option::Some(message::Union::test_delay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_test_delay(&mut self) -> &mut TestDelay {
        if let ::std::option::Option::Some(message::Union::test_delay(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::test_delay(TestDelay::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::test_delay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_test_delay(&mut self) -> TestDelay {
        if self.has_test_delay() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::test_delay(v)) => v,
                _ => panic!(),
            }
        } else {
            TestDelay::new()
        }
    }

    // .hbb.VideoFrame video_frame = 6;

    pub fn get_video_frame(&self) -> &VideoFrame {
        match self.union {
            ::std::option::Option::Some(message::Union::video_frame(ref v)) => v,
            _ => <VideoFrame as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_video_frame(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_video_frame(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::video_frame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_video_frame(&mut self, v: VideoFrame) {
        self.union = ::std::option::Option::Some(message::Union::video_frame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_video_frame(&mut self) -> &mut VideoFrame {
        if let ::std::option::Option::Some(message::Union::video_frame(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::video_frame(VideoFrame::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::video_frame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_video_frame(&mut self) -> VideoFrame {
        if self.has_video_frame() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::video_frame(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoFrame::new()
        }
    }

    // .hbb.LoginRequest login_request = 7;

    pub fn get_login_request(&self) -> &LoginRequest {
        match self.union {
            ::std::option::Option::Some(message::Union::login_request(ref v)) => v,
            _ => <LoginRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_login_request(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_login_request(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::login_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_login_request(&mut self, v: LoginRequest) {
        self.union = ::std::option::Option::Some(message::Union::login_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_login_request(&mut self) -> &mut LoginRequest {
        if let ::std::option::Option::Some(message::Union::login_request(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::login_request(LoginRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::login_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_login_request(&mut self) -> LoginRequest {
        if self.has_login_request() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::login_request(v)) => v,
                _ => panic!(),
            }
        } else {
            LoginRequest::new()
        }
    }

    // .hbb.LoginResponse login_response = 8;

    pub fn get_login_response(&self) -> &LoginResponse {
        match self.union {
            ::std::option::Option::Some(message::Union::login_response(ref v)) => v,
            _ => <LoginResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_login_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_login_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::login_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_login_response(&mut self, v: LoginResponse) {
        self.union = ::std::option::Option::Some(message::Union::login_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_login_response(&mut self) -> &mut LoginResponse {
        if let ::std::option::Option::Some(message::Union::login_response(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::login_response(LoginResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::login_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_login_response(&mut self) -> LoginResponse {
        if self.has_login_response() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::login_response(v)) => v,
                _ => panic!(),
            }
        } else {
            LoginResponse::new()
        }
    }

    // .hbb.Hash hash = 9;

    pub fn get_hash(&self) -> &Hash {
        match self.union {
            ::std::option::Option::Some(message::Union::hash(ref v)) => v,
            _ => <Hash as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_hash(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::hash(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: Hash) {
        self.union = ::std::option::Option::Some(message::Union::hash(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hash(&mut self) -> &mut Hash {
        if let ::std::option::Option::Some(message::Union::hash(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::hash(Hash::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::hash(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hash(&mut self) -> Hash {
        if self.has_hash() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::hash(v)) => v,
                _ => panic!(),
            }
        } else {
            Hash::new()
        }
    }

    // .hbb.MouseEvent mouse_event = 10;

    pub fn get_mouse_event(&self) -> &MouseEvent {
        match self.union {
            ::std::option::Option::Some(message::Union::mouse_event(ref v)) => v,
            _ => <MouseEvent as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mouse_event(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_mouse_event(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::mouse_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mouse_event(&mut self, v: MouseEvent) {
        self.union = ::std::option::Option::Some(message::Union::mouse_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mouse_event(&mut self) -> &mut MouseEvent {
        if let ::std::option::Option::Some(message::Union::mouse_event(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::mouse_event(MouseEvent::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::mouse_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mouse_event(&mut self) -> MouseEvent {
        if self.has_mouse_event() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::mouse_event(v)) => v,
                _ => panic!(),
            }
        } else {
            MouseEvent::new()
        }
    }

    // .hbb.AudioFrame audio_frame = 11;

    pub fn get_audio_frame(&self) -> &AudioFrame {
        match self.union {
            ::std::option::Option::Some(message::Union::audio_frame(ref v)) => v,
            _ => <AudioFrame as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_audio_frame(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_audio_frame(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::audio_frame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_audio_frame(&mut self, v: AudioFrame) {
        self.union = ::std::option::Option::Some(message::Union::audio_frame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_audio_frame(&mut self) -> &mut AudioFrame {
        if let ::std::option::Option::Some(message::Union::audio_frame(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::audio_frame(AudioFrame::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::audio_frame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_audio_frame(&mut self) -> AudioFrame {
        if self.has_audio_frame() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::audio_frame(v)) => v,
                _ => panic!(),
            }
        } else {
            AudioFrame::new()
        }
    }

    // .hbb.CursorData cursor_data = 12;

    pub fn get_cursor_data(&self) -> &CursorData {
        match self.union {
            ::std::option::Option::Some(message::Union::cursor_data(ref v)) => v,
            _ => <CursorData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cursor_data(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_cursor_data(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::cursor_data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cursor_data(&mut self, v: CursorData) {
        self.union = ::std::option::Option::Some(message::Union::cursor_data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cursor_data(&mut self) -> &mut CursorData {
        if let ::std::option::Option::Some(message::Union::cursor_data(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::cursor_data(CursorData::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::cursor_data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cursor_data(&mut self) -> CursorData {
        if self.has_cursor_data() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::cursor_data(v)) => v,
                _ => panic!(),
            }
        } else {
            CursorData::new()
        }
    }

    // .hbb.CursorPosition cursor_position = 13;

    pub fn get_cursor_position(&self) -> &CursorPosition {
        match self.union {
            ::std::option::Option::Some(message::Union::cursor_position(ref v)) => v,
            _ => <CursorPosition as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cursor_position(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_cursor_position(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::cursor_position(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cursor_position(&mut self, v: CursorPosition) {
        self.union = ::std::option::Option::Some(message::Union::cursor_position(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cursor_position(&mut self) -> &mut CursorPosition {
        if let ::std::option::Option::Some(message::Union::cursor_position(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::cursor_position(CursorPosition::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::cursor_position(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cursor_position(&mut self) -> CursorPosition {
        if self.has_cursor_position() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::cursor_position(v)) => v,
                _ => panic!(),
            }
        } else {
            CursorPosition::new()
        }
    }

    // uint64 cursor_id = 14;

    pub fn get_cursor_id(&self) -> u64 {
        match self.union {
            ::std::option::Option::Some(message::Union::cursor_id(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_cursor_id(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::cursor_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.union = ::std::option::Option::Some(message::Union::cursor_id(v))
    }

    // .hbb.KeyEvent key_event = 15;

    pub fn get_key_event(&self) -> &KeyEvent {
        match self.union {
            ::std::option::Option::Some(message::Union::key_event(ref v)) => v,
            _ => <KeyEvent as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_key_event(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_key_event(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::key_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key_event(&mut self, v: KeyEvent) {
        self.union = ::std::option::Option::Some(message::Union::key_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key_event(&mut self) -> &mut KeyEvent {
        if let ::std::option::Option::Some(message::Union::key_event(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::key_event(KeyEvent::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::key_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key_event(&mut self) -> KeyEvent {
        if self.has_key_event() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::key_event(v)) => v,
                _ => panic!(),
            }
        } else {
            KeyEvent::new()
        }
    }

    // .hbb.Clipboard clipboard = 16;

    pub fn get_clipboard(&self) -> &Clipboard {
        match self.union {
            ::std::option::Option::Some(message::Union::clipboard(ref v)) => v,
            _ => <Clipboard as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_clipboard(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_clipboard(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::clipboard(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_clipboard(&mut self, v: Clipboard) {
        self.union = ::std::option::Option::Some(message::Union::clipboard(v))
    }

    // Mutable pointer to the field.
    pub fn mut_clipboard(&mut self) -> &mut Clipboard {
        if let ::std::option::Option::Some(message::Union::clipboard(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::clipboard(Clipboard::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::clipboard(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_clipboard(&mut self) -> Clipboard {
        if self.has_clipboard() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::clipboard(v)) => v,
                _ => panic!(),
            }
        } else {
            Clipboard::new()
        }
    }

    // .hbb.FileAction file_action = 17;

    pub fn get_file_action(&self) -> &FileAction {
        match self.union {
            ::std::option::Option::Some(message::Union::file_action(ref v)) => v,
            _ => <FileAction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_file_action(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_file_action(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::file_action(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_action(&mut self, v: FileAction) {
        self.union = ::std::option::Option::Some(message::Union::file_action(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_action(&mut self) -> &mut FileAction {
        if let ::std::option::Option::Some(message::Union::file_action(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::file_action(FileAction::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::file_action(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_action(&mut self) -> FileAction {
        if self.has_file_action() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::file_action(v)) => v,
                _ => panic!(),
            }
        } else {
            FileAction::new()
        }
    }

    // .hbb.FileResponse file_response = 18;

    pub fn get_file_response(&self) -> &FileResponse {
        match self.union {
            ::std::option::Option::Some(message::Union::file_response(ref v)) => v,
            _ => <FileResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_file_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_file_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::file_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_response(&mut self, v: FileResponse) {
        self.union = ::std::option::Option::Some(message::Union::file_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_response(&mut self) -> &mut FileResponse {
        if let ::std::option::Option::Some(message::Union::file_response(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::file_response(FileResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::file_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_response(&mut self) -> FileResponse {
        if self.has_file_response() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::file_response(v)) => v,
                _ => panic!(),
            }
        } else {
            FileResponse::new()
        }
    }

    // .hbb.Misc misc = 19;

    pub fn get_misc(&self) -> &Misc {
        match self.union {
            ::std::option::Option::Some(message::Union::misc(ref v)) => v,
            _ => <Misc as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_misc(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_misc(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::misc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_misc(&mut self, v: Misc) {
        self.union = ::std::option::Option::Some(message::Union::misc(v))
    }

    // Mutable pointer to the field.
    pub fn mut_misc(&mut self) -> &mut Misc {
        if let ::std::option::Option::Some(message::Union::misc(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::misc(Misc::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::misc(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_misc(&mut self) -> Misc {
        if self.has_misc() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::misc(v)) => v,
                _ => panic!(),
            }
        } else {
            Misc::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SignedId>(
            "signed_id",
            Message::has_signed_id,
            Message::get_signed_id,
            Message::mut_signed_id,
            Message::set_signed_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PublicKey>(
            "public_key",
            Message::has_public_key,
            Message::get_public_key,
            Message::mut_public_key,
            Message::set_public_key,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TestDelay>(
            "test_delay",
            Message::has_test_delay,
            Message::get_test_delay,
            Message::mut_test_delay,
            Message::set_test_delay,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VideoFrame>(
            "video_frame",
            Message::has_video_frame,
            Message::get_video_frame,
            Message::mut_video_frame,
            Message::set_video_frame,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LoginRequest>(
            "login_request",
            Message::has_login_request,
            Message::get_login_request,
            Message::mut_login_request,
            Message::set_login_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LoginResponse>(
            "login_response",
            Message::has_login_response,
            Message::get_login_response,
            Message::mut_login_response,
            Message::set_login_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Hash>(
            "hash",
            Message::has_hash,
            Message::get_hash,
            Message::mut_hash,
            Message::set_hash,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MouseEvent>(
            "mouse_event",
            Message::has_mouse_event,
            Message::get_mouse_event,
            Message::mut_mouse_event,
            Message::set_mouse_event,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AudioFrame>(
            "audio_frame",
            Message::has_audio_frame,
            Message::get_audio_frame,
            Message::mut_audio_frame,
            Message::set_audio_frame,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CursorData>(
            "cursor_data",
            Message::has_cursor_data,
            Message::get_cursor_data,
            Message::mut_cursor_data,
            Message::set_cursor_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CursorPosition>(
            "cursor_position",
            Message::has_cursor_position,
            Message::get_cursor_position,
            Message::mut_cursor_position,
            Message::set_cursor_position,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "cursor_id",
            Message::has_cursor_id,
            Message::get_cursor_id,
            Message::set_cursor_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, KeyEvent>(
            "key_event",
            Message::has_key_event,
            Message::get_key_event,
            Message::mut_key_event,
            Message::set_key_event,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Clipboard>(
            "clipboard",
            Message::has_clipboard,
            Message::get_clipboard,
            Message::mut_clipboard,
            Message::set_clipboard,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileAction>(
            "file_action",
            Message::has_file_action,
            Message::get_file_action,
            Message::mut_file_action,
            Message::set_file_action,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileResponse>(
            "file_response",
            Message::has_file_response,
            Message::get_file_response,
            Message::mut_file_response,
            Message::set_file_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Misc>(
            "misc",
            Message::has_misc,
            Message::get_misc,
            Message::mut_misc,
            Message::set_misc,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
            "Message",
            42,
            fields,
        )
    }
}

impl ::protobuf::Message for Message {
    fn is_initialized(&self) -> bool {
        if let Some(message::Union::signed_id(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(message::Union::public_key(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(message::Union::test_delay(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(message::Union::video_frame(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(message::Union::login_request(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(message::Union::login_response(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(message::Union::hash(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(message::Union::mouse_event(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(message::Union::audio_frame(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(message::Union::cursor_data(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(message::Union::cursor_position(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(message::Union::key_event(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(message::Union::clipboard(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(message::Union::file_action(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(message::Union::file_response(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(message::Union::misc(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::signed_id(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::public_key(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::test_delay(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::video_frame(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::login_request(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::login_response(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::hash(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::mouse_event(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::audio_frame(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::cursor_data(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::cursor_position(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::cursor_id(is.read_uint64()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::key_event(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::clipboard(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::file_action(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::file_response(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(message::Union::misc(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &message::Union::signed_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &message::Union::public_key(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &message::Union::test_delay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &message::Union::video_frame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &message::Union::login_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &message::Union::login_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &message::Union::hash(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &message::Union::mouse_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &message::Union::audio_frame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &message::Union::cursor_data(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &message::Union::cursor_position(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &message::Union::cursor_id(v) => {
                    my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &message::Union::key_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &message::Union::clipboard(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &message::Union::file_action(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &message::Union::file_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &message::Union::misc(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &message::Union::signed_id(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &message::Union::public_key(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &message::Union::test_delay(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &message::Union::video_frame(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &message::Union::login_request(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &message::Union::login_response(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &message::Union::hash(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &message::Union::mouse_event(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &message::Union::audio_frame(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &message::Union::cursor_data(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &message::Union::cursor_position(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &message::Union::cursor_id(v) => {
                    os.write_uint64(14, v)?;
                },
                &message::Union::key_event(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &message::Union::clipboard(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
                &message::Union::file_action(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                },
                &message::Union::file_response(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
                &message::Union::misc(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Message {
        Message::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 42)
    }

    fn default_instance() -> &'static Message {
        static instance: Message = Message {
            union: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Message {
    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Message`
pub mod message {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Union {
        signed_id(super::SignedId),
        public_key(super::PublicKey),
        test_delay(super::TestDelay),
        video_frame(super::VideoFrame),
        login_request(super::LoginRequest),
        login_response(super::LoginResponse),
        hash(super::Hash),
        mouse_event(super::MouseEvent),
        audio_frame(super::AudioFrame),
        cursor_data(super::CursorData),
        cursor_position(super::CursorPosition),
        cursor_id(u64),
        key_event(super::KeyEvent),
        clipboard(super::Clipboard),
        file_action(super::FileAction),
        file_response(super::FileResponse),
        misc(super::Misc),
    }

    impl ::protobuf::Oneof for Union {
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum ControlKey {
    Alt = 1,
    Backspace = 2,
    CapsLock = 3,
    Control = 4,
    Delete = 5,
    DownArrow = 6,
    End = 7,
    Escape = 8,
    F1 = 9,
    F10 = 10,
    F11 = 11,
    F12 = 12,
    F2 = 13,
    F3 = 14,
    F4 = 15,
    F5 = 16,
    F6 = 17,
    F7 = 18,
    F8 = 19,
    F9 = 20,
    Home = 21,
    LeftArrow = 22,
    Meta = 23,
    Option = 24,
    PageDown = 25,
    PageUp = 26,
    Return = 27,
    RightArrow = 28,
    Shift = 29,
    Space = 30,
    Tab = 31,
    UpArrow = 32,
    Numpad0 = 33,
    Numpad1 = 34,
    Numpad2 = 35,
    Numpad3 = 36,
    Numpad4 = 37,
    Numpad5 = 38,
    Numpad6 = 39,
    Numpad7 = 40,
    Numpad8 = 41,
    Numpad9 = 42,
    Cancel = 43,
    Clear = 44,
    Menu = 45,
    Pause = 46,
    Kana = 47,
    Hangul = 48,
    Junja = 49,
    Final = 50,
    Hanja = 51,
    Kanji = 52,
    Convert = 53,
    Select = 54,
    Print = 55,
    Execute = 56,
    Snapshot = 57,
    Insert = 58,
    Help = 59,
    Sleep = 60,
    Separator = 61,
    Scroll = 62,
    NumLock = 63,
    RWin = 64,
    Apps = 65,
    Multiply = 66,
    Add = 67,
    Subtract = 68,
    Decimal = 69,
    Divide = 70,
    Equals = 71,
    NumpadEnter = 72,
    RShift = 73,
    RControl = 74,
    RAlt = 75,
    CtrlAltDel = 100,
    LockScreen = 101,
}

impl ::protobuf::ProtobufEnum for ControlKey {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ControlKey> {
        match value {
            1 => ::std::option::Option::Some(ControlKey::Alt),
            2 => ::std::option::Option::Some(ControlKey::Backspace),
            3 => ::std::option::Option::Some(ControlKey::CapsLock),
            4 => ::std::option::Option::Some(ControlKey::Control),
            5 => ::std::option::Option::Some(ControlKey::Delete),
            6 => ::std::option::Option::Some(ControlKey::DownArrow),
            7 => ::std::option::Option::Some(ControlKey::End),
            8 => ::std::option::Option::Some(ControlKey::Escape),
            9 => ::std::option::Option::Some(ControlKey::F1),
            10 => ::std::option::Option::Some(ControlKey::F10),
            11 => ::std::option::Option::Some(ControlKey::F11),
            12 => ::std::option::Option::Some(ControlKey::F12),
            13 => ::std::option::Option::Some(ControlKey::F2),
            14 => ::std::option::Option::Some(ControlKey::F3),
            15 => ::std::option::Option::Some(ControlKey::F4),
            16 => ::std::option::Option::Some(ControlKey::F5),
            17 => ::std::option::Option::Some(ControlKey::F6),
            18 => ::std::option::Option::Some(ControlKey::F7),
            19 => ::std::option::Option::Some(ControlKey::F8),
            20 => ::std::option::Option::Some(ControlKey::F9),
            21 => ::std::option::Option::Some(ControlKey::Home),
            22 => ::std::option::Option::Some(ControlKey::LeftArrow),
            23 => ::std::option::Option::Some(ControlKey::Meta),
            24 => ::std::option::Option::Some(ControlKey::Option),
            25 => ::std::option::Option::Some(ControlKey::PageDown),
            26 => ::std::option::Option::Some(ControlKey::PageUp),
            27 => ::std::option::Option::Some(ControlKey::Return),
            28 => ::std::option::Option::Some(ControlKey::RightArrow),
            29 => ::std::option::Option::Some(ControlKey::Shift),
            30 => ::std::option::Option::Some(ControlKey::Space),
            31 => ::std::option::Option::Some(ControlKey::Tab),
            32 => ::std::option::Option::Some(ControlKey::UpArrow),
            33 => ::std::option::Option::Some(ControlKey::Numpad0),
            34 => ::std::option::Option::Some(ControlKey::Numpad1),
            35 => ::std::option::Option::Some(ControlKey::Numpad2),
            36 => ::std::option::Option::Some(ControlKey::Numpad3),
            37 => ::std::option::Option::Some(ControlKey::Numpad4),
            38 => ::std::option::Option::Some(ControlKey::Numpad5),
            39 => ::std::option::Option::Some(ControlKey::Numpad6),
            40 => ::std::option::Option::Some(ControlKey::Numpad7),
            41 => ::std::option::Option::Some(ControlKey::Numpad8),
            42 => ::std::option::Option::Some(ControlKey::Numpad9),
            43 => ::std::option::Option::Some(ControlKey::Cancel),
            44 => ::std::option::Option::Some(ControlKey::Clear),
            45 => ::std::option::Option::Some(ControlKey::Menu),
            46 => ::std::option::Option::Some(ControlKey::Pause),
            47 => ::std::option::Option::Some(ControlKey::Kana),
            48 => ::std::option::Option::Some(ControlKey::Hangul),
            49 => ::std::option::Option::Some(ControlKey::Junja),
            50 => ::std::option::Option::Some(ControlKey::Final),
            51 => ::std::option::Option::Some(ControlKey::Hanja),
            52 => ::std::option::Option::Some(ControlKey::Kanji),
            53 => ::std::option::Option::Some(ControlKey::Convert),
            54 => ::std::option::Option::Some(ControlKey::Select),
            55 => ::std::option::Option::Some(ControlKey::Print),
            56 => ::std::option::Option::Some(ControlKey::Execute),
            57 => ::std::option::Option::Some(ControlKey::Snapshot),
            58 => ::std::option::Option::Some(ControlKey::Insert),
            59 => ::std::option::Option::Some(ControlKey::Help),
            60 => ::std::option::Option::Some(ControlKey::Sleep),
            61 => ::std::option::Option::Some(ControlKey::Separator),
            62 => ::std::option::Option::Some(ControlKey::Scroll),
            63 => ::std::option::Option::Some(ControlKey::NumLock),
            64 => ::std::option::Option::Some(ControlKey::RWin),
            65 => ::std::option::Option::Some(ControlKey::Apps),
            66 => ::std::option::Option::Some(ControlKey::Multiply),
            67 => ::std::option::Option::Some(ControlKey::Add),
            68 => ::std::option::Option::Some(ControlKey::Subtract),
            69 => ::std::option::Option::Some(ControlKey::Decimal),
            70 => ::std::option::Option::Some(ControlKey::Divide),
            71 => ::std::option::Option::Some(ControlKey::Equals),
            72 => ::std::option::Option::Some(ControlKey::NumpadEnter),
            73 => ::std::option::Option::Some(ControlKey::RShift),
            74 => ::std::option::Option::Some(ControlKey::RControl),
            75 => ::std::option::Option::Some(ControlKey::RAlt),
            100 => ::std::option::Option::Some(ControlKey::CtrlAltDel),
            101 => ::std::option::Option::Some(ControlKey::LockScreen),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ControlKey] = &[
            ControlKey::Alt,
            ControlKey::Backspace,
            ControlKey::CapsLock,
            ControlKey::Control,
            ControlKey::Delete,
            ControlKey::DownArrow,
            ControlKey::End,
            ControlKey::Escape,
            ControlKey::F1,
            ControlKey::F10,
            ControlKey::F11,
            ControlKey::F12,
            ControlKey::F2,
            ControlKey::F3,
            ControlKey::F4,
            ControlKey::F5,
            ControlKey::F6,
            ControlKey::F7,
            ControlKey::F8,
            ControlKey::F9,
            ControlKey::Home,
            ControlKey::LeftArrow,
            ControlKey::Meta,
            ControlKey::Option,
            ControlKey::PageDown,
            ControlKey::PageUp,
            ControlKey::Return,
            ControlKey::RightArrow,
            ControlKey::Shift,
            ControlKey::Space,
            ControlKey::Tab,
            ControlKey::UpArrow,
            ControlKey::Numpad0,
            ControlKey::Numpad1,
            ControlKey::Numpad2,
            ControlKey::Numpad3,
            ControlKey::Numpad4,
            ControlKey::Numpad5,
            ControlKey::Numpad6,
            ControlKey::Numpad7,
            ControlKey::Numpad8,
            ControlKey::Numpad9,
            ControlKey::Cancel,
            ControlKey::Clear,
            ControlKey::Menu,
            ControlKey::Pause,
            ControlKey::Kana,
            ControlKey::Hangul,
            ControlKey::Junja,
            ControlKey::Final,
            ControlKey::Hanja,
            ControlKey::Kanji,
            ControlKey::Convert,
            ControlKey::Select,
            ControlKey::Print,
            ControlKey::Execute,
            ControlKey::Snapshot,
            ControlKey::Insert,
            ControlKey::Help,
            ControlKey::Sleep,
            ControlKey::Separator,
            ControlKey::Scroll,
            ControlKey::NumLock,
            ControlKey::RWin,
            ControlKey::Apps,
            ControlKey::Multiply,
            ControlKey::Add,
            ControlKey::Subtract,
            ControlKey::Decimal,
            ControlKey::Divide,
            ControlKey::Equals,
            ControlKey::NumpadEnter,
            ControlKey::RShift,
            ControlKey::RControl,
            ControlKey::RAlt,
            ControlKey::CtrlAltDel,
            ControlKey::LockScreen,
        ];
        values
    }

    fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
        ::protobuf::reflect::EnumDescriptor::new_generated_2(file_descriptor(), 0)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ControlKey {
    fn default() -> Self {
        ControlKey::Alt
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlKey {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
}

impl ControlKey {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<ControlKey>("ControlKey", 0)
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum FileType {
    Dir = 1,
    DirLink = 2,
    DirDrive = 3,
    File = 4,
    FileLink = 5,
}

impl ::protobuf::ProtobufEnum for FileType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FileType> {
        match value {
            1 => ::std::option::Option::Some(FileType::Dir),
            2 => ::std::option::Option::Some(FileType::DirLink),
            3 => ::std::option::Option::Some(FileType::DirDrive),
            4 => ::std::option::Option::Some(FileType::File),
            5 => ::std::option::Option::Some(FileType::FileLink),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FileType] = &[
            FileType::Dir,
            FileType::DirLink,
            FileType::DirDrive,
            FileType::File,
            FileType::FileLink,
        ];
        values
    }

    fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
        ::protobuf::reflect::EnumDescriptor::new_generated_2(file_descriptor(), 1)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for FileType {
    fn default() -> Self {
        FileType::Dir
    }
}

impl ::protobuf::reflect::ProtobufValue for FileType {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
}

impl FileType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<FileType>("FileType", 1)
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum Permission {
    Keyboard = 1,
    Clipboard = 2,
    Audio = 3,
}

impl ::protobuf::ProtobufEnum for Permission {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Permission> {
        match value {
            1 => ::std::option::Option::Some(Permission::Keyboard),
            2 => ::std::option::Option::Some(Permission::Clipboard),
            3 => ::std::option::Option::Some(Permission::Audio),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Permission] = &[
            Permission::Keyboard,
            Permission::Clipboard,
            Permission::Audio,
        ];
        values
    }

    fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
        ::protobuf::reflect::EnumDescriptor::new_generated_2(file_descriptor(), 2)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Permission {
    fn default() -> Self {
        Permission::Keyboard
    }
}

impl ::protobuf::reflect::ProtobufValue for Permission {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
}

impl Permission {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<Permission>("Permission", 2)
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum ImageQuality {
    NotSet = 0,
    Low = 2,
    Balanced = 3,
    Best = 4,
}

impl ::protobuf::ProtobufEnum for ImageQuality {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ImageQuality> {
        match value {
            0 => ::std::option::Option::Some(ImageQuality::NotSet),
            2 => ::std::option::Option::Some(ImageQuality::Low),
            3 => ::std::option::Option::Some(ImageQuality::Balanced),
            4 => ::std::option::Option::Some(ImageQuality::Best),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ImageQuality] = &[
            ImageQuality::NotSet,
            ImageQuality::Low,
            ImageQuality::Balanced,
            ImageQuality::Best,
        ];
        values
    }

    fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
        ::protobuf::reflect::EnumDescriptor::new_generated_2(file_descriptor(), 3)
    }
}

impl ::std::default::Default for ImageQuality {
    fn default() -> Self {
        ImageQuality::NotSet
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageQuality {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
}

impl ImageQuality {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<ImageQuality>("ImageQuality", 3)
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum BoolOption {
    NotSet = 0,
    No = 1,
    Yes = 2,
}

impl ::protobuf::ProtobufEnum for BoolOption {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BoolOption> {
        match value {
            0 => ::std::option::Option::Some(BoolOption::NotSet),
            1 => ::std::option::Option::Some(BoolOption::No),
            2 => ::std::option::Option::Some(BoolOption::Yes),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BoolOption] = &[
            BoolOption::NotSet,
            BoolOption::No,
            BoolOption::Yes,
        ];
        values
    }

    fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
        ::protobuf::reflect::EnumDescriptor::new_generated_2(file_descriptor(), 4)
    }
}

impl ::std::default::Default for BoolOption {
    fn default() -> Self {
        BoolOption::NotSet
    }
}

impl ::protobuf::reflect::ProtobufValue for BoolOption {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
}

impl BoolOption {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<BoolOption>("BoolOption", 4)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rmessage.proto\x12\x03hbb\"E\n\x03VP9\x12\x14\n\x04data\x18\x01\x20\
    \x01(\x0cR\x04dataB\0\x12\x12\n\x03key\x18\x02\x20\x01(\x08R\x03keyB\0\
    \x12\x12\n\x03pts\x18\x03\x20\x01(\x03R\x03ptsB\0:\0\",\n\x04VP9s\x12\"\
    \n\x06frames\x18\x01\x20\x03(\x0b2\x08.hbb.VP9R\x06framesB\0:\0\"%\n\x03\
    RGB\x12\x1c\n\x08compress\x18\x01\x20\x01(\x08R\x08compressB\0:\0\"?\n\
    \x03YUV\x12\x1c\n\x08compress\x18\x01\x20\x01(\x08R\x08compressB\0\x12\
    \x18\n\x06stride\x18\x02\x20\x01(\x05R\x06strideB\0:\0\"|\n\nVideoFrame\
    \x12!\n\x04vp9s\x18\x06\x20\x01(\x0b2\t.hbb.VP9sH\0R\x04vp9sB\0\x12\x1e\
    \n\x03rgb\x18\x07\x20\x01(\x0b2\x08.hbb.RGBH\0R\x03rgbB\0\x12\x1e\n\x03y\
    uv\x18\x08\x20\x01(\x0b2\x08.hbb.YUVH\0R\x03yuvB\0B\t\n\x05union\x12\0:\
    \0\"\x91\x01\n\x0bDisplayInfo\x12\x0e\n\x01x\x18\x01\x20\x01(\x11R\x01xB\
    \0\x12\x0e\n\x01y\x18\x02\x20\x01(\x11R\x01yB\0\x12\x16\n\x05width\x18\
    \x03\x20\x01(\x05R\x05widthB\0\x12\x18\n\x06height\x18\x04\x20\x01(\x05R\
    \x06heightB\0\x12\x14\n\x04name\x18\x05\x20\x01(\tR\x04nameB\0\x12\x18\n\
    \x06online\x18\x06\x20\x01(\x08R\x06onlineB\0:\0\";\n\x0bPortForward\x12\
    \x14\n\x04host\x18\x01\x20\x01(\tR\x04hostB\0\x12\x14\n\x04port\x18\x02\
    \x20\x01(\x05R\x04portB\0:\0\"G\n\x0cFileTransfer\x12\x12\n\x03dir\x18\
    \x01\x20\x01(\tR\x03dirB\0\x12!\n\x0bshow_hidden\x18\x02\x20\x01(\x08R\n\
    showHiddenB\0:\0\"\xac\x02\n\x0cLoginRequest\x12\x1c\n\x08username\x18\
    \x01\x20\x01(\tR\x08usernameB\0\x12\x1c\n\x08password\x18\x02\x20\x01(\
    \x0cR\x08passwordB\0\x12\x15\n\x05my_id\x18\x04\x20\x01(\tR\x04myIdB\0\
    \x12\x19\n\x07my_name\x18\x05\x20\x01(\tR\x06myNameB\0\x12,\n\x06option\
    \x18\x06\x20\x01(\x0b2\x12.hbb.OptionMessageR\x06optionB\0\x12:\n\rfile_\
    transfer\x18\x07\x20\x01(\x0b2\x11.hbb.FileTransferH\0R\x0cfileTransferB\
    \0\x127\n\x0cport_forward\x18\x08\x20\x01(\x0b2\x10.hbb.PortForwardH\0R\
    \x0bportForwardB\0B\t\n\x05union\x12\0:\0\"%\n\x0bChatMessage\x12\x14\n\
    \x04text\x18\x01\x20\x01(\tR\x04textB\0:\0\"\x80\x02\n\x08PeerInfo\x12\
    \x1c\n\x08username\x18\x01\x20\x01(\tR\x08usernameB\0\x12\x1c\n\x08hostn\
    ame\x18\x02\x20\x01(\tR\x08hostnameB\0\x12\x1c\n\x08platform\x18\x03\x20\
    \x01(\tR\x08platformB\0\x12.\n\x08displays\x18\x04\x20\x03(\x0b2\x10.hbb\
    .DisplayInfoR\x08displaysB\0\x12)\n\x0fcurrent_display\x18\x05\x20\x01(\
    \x05R\x0ecurrentDisplayB\0\x12!\n\x0bsas_enabled\x18\x06\x20\x01(\x08R\n\
    sasEnabledB\0\x12\x1a\n\x07version\x18\x07\x20\x01(\tR\x07versionB\0:\0\
    \"f\n\rLoginResponse\x12\x18\n\x05error\x18\x01\x20\x01(\tH\0R\x05errorB\
    \0\x12.\n\tpeer_info\x18\x02\x20\x01(\x0b2\r.hbb.PeerInfoH\0R\x08peerInf\
    oB\0B\t\n\x05union\x12\0:\0\"u\n\nMouseEvent\x12\x14\n\x04mask\x18\x01\
    \x20\x01(\x05R\x04maskB\0\x12\x0e\n\x01x\x18\x02\x20\x01(\x11R\x01xB\0\
    \x12\x0e\n\x01y\x18\x03\x20\x01(\x11R\x01yB\0\x12/\n\tmodifiers\x18\x04\
    \x20\x03(\x0e2\x0f.hbb.ControlKeyR\tmodifiersB\0:\0\"\xf6\x01\n\x08KeyEv\
    ent\x12\x14\n\x04down\x18\x01\x20\x01(\x08R\x04downB\0\x12\x16\n\x05pres\
    s\x18\x02\x20\x01(\x08R\x05pressB\0\x124\n\x0bcontrol_key\x18\x03\x20\
    \x01(\x0e2\x0f.hbb.ControlKeyH\0R\ncontrolKeyB\0\x12\x14\n\x03chr\x18\
    \x04\x20\x01(\rH\0R\x03chrB\0\x12\x1c\n\x07unicode\x18\x05\x20\x01(\rH\0\
    R\x07unicodeB\0\x12\x14\n\x03seq\x18\x06\x20\x01(\tH\0R\x03seqB\0\x12/\n\
    \tmodifiers\x18\x08\x20\x03(\x0e2\x0f.hbb.ControlKeyR\tmodifiersB\0B\t\n\
    \x05union\x12\0:\0\"\x98\x01\n\nCursorData\x12\x10\n\x02id\x18\x01\x20\
    \x01(\x04R\x02idB\0\x12\x14\n\x04hotx\x18\x02\x20\x01(\x11R\x04hotxB\0\
    \x12\x14\n\x04hoty\x18\x03\x20\x01(\x11R\x04hotyB\0\x12\x16\n\x05width\
    \x18\x04\x20\x01(\x05R\x05widthB\0\x12\x18\n\x06height\x18\x05\x20\x01(\
    \x05R\x06heightB\0\x12\x18\n\x06colors\x18\x06\x20\x01(\x0cR\x06colorsB\
    \0:\0\"2\n\x0eCursorPosition\x12\x0e\n\x01x\x18\x01\x20\x01(\x11R\x01xB\
    \0\x12\x0e\n\x01y\x18\x02\x20\x01(\x11R\x01yB\0:\0\">\n\x04Hash\x12\x14\
    \n\x04salt\x18\x01\x20\x01(\tR\x04saltB\0\x12\x1e\n\tchallenge\x18\x02\
    \x20\x01(\tR\tchallengeB\0:\0\"G\n\tClipboard\x12\x1c\n\x08compress\x18\
    \x01\x20\x01(\x08R\x08compressB\0\x12\x1a\n\x07content\x18\x02\x20\x01(\
    \x0cR\x07contentB\0:\0\"\xaf\x01\n\tFileEntry\x12.\n\nentry_type\x18\x01\
    \x20\x01(\x0e2\r.hbb.FileTypeR\tentryTypeB\0\x12\x14\n\x04name\x18\x02\
    \x20\x01(\tR\x04nameB\0\x12\x1d\n\tis_hidden\x18\x03\x20\x01(\x08R\x08is\
    HiddenB\0\x12\x14\n\x04size\x18\x04\x20\x01(\x04R\x04sizeB\0\x12%\n\rmod\
    ified_time\x18\x05\x20\x01(\x04R\x0cmodifiedTimeB\0:\0\"e\n\rFileDirecto\
    ry\x12\x10\n\x02id\x18\x01\x20\x01(\x05R\x02idB\0\x12\x14\n\x04path\x18\
    \x02\x20\x01(\tR\x04pathB\0\x12*\n\x07entries\x18\x03\x20\x03(\x0b2\x0e.\
    hbb.FileEntryR\x07entriesB\0:\0\"J\n\x07ReadDir\x12\x14\n\x04path\x18\
    \x01\x20\x01(\tR\x04pathB\0\x12'\n\x0einclude_hidden\x18\x02\x20\x01(\
    \x08R\rincludeHiddenB\0:\0\"a\n\x0cReadAllFiles\x12\x10\n\x02id\x18\x01\
    \x20\x01(\x05R\x02idB\0\x12\x14\n\x04path\x18\x02\x20\x01(\tR\x04pathB\0\
    \x12'\n\x0einclude_hidden\x18\x03\x20\x01(\x08R\rincludeHiddenB\0:\0\"\
    \xc5\x03\n\nFileAction\x12+\n\x08read_dir\x18\x01\x20\x01(\x0b2\x0c.hbb.\
    ReadDirH\0R\x07readDirB\0\x124\n\x04send\x18\x02\x20\x01(\x0b2\x1c.hbb.F\
    ileTransferSendRequestH\0R\x04sendB\0\x12=\n\x07receive\x18\x03\x20\x01(\
    \x0b2\x1f.hbb.FileTransferReceiveRequestH\0R\x07receiveB\0\x12.\n\x06cre\
    ate\x18\x04\x20\x01(\x0b2\x12.hbb.FileDirCreateH\0R\x06createB\0\x125\n\
    \nremove_dir\x18\x05\x20\x01(\x0b2\x12.hbb.FileRemoveDirH\0R\tremoveDirB\
    \0\x128\n\x0bremove_file\x18\x06\x20\x01(\x0b2\x13.hbb.FileRemoveFileH\0\
    R\nremoveFileB\0\x122\n\tall_files\x18\x07\x20\x01(\x0b2\x11.hbb.ReadAll\
    FilesH\0R\x08allFilesB\0\x123\n\x06cancel\x18\x08\x20\x01(\x0b2\x17.hbb.\
    FileTransferCancelH\0R\x06cancelB\0B\t\n\x05union\x12\0:\0\"(\n\x12FileT\
    ransferCancel\x12\x10\n\x02id\x18\x01\x20\x01(\x05R\x02idB\0:\0\"\xd8\
    \x01\n\x0cFileResponse\x12(\n\x03dir\x18\x01\x20\x01(\x0b2\x12.hbb.FileD\
    irectoryH\0R\x03dirB\0\x120\n\x05block\x18\x02\x20\x01(\x0b2\x16.hbb.Fil\
    eTransferBlockH\0R\x05blockB\0\x120\n\x05error\x18\x03\x20\x01(\x0b2\x16\
    .hbb.FileTransferErrorH\0R\x05errorB\0\x12-\n\x04done\x18\x04\x20\x01(\
    \x0b2\x15.hbb.FileTransferDoneH\0R\x04doneB\0B\t\n\x05union\x12\0:\0\"|\
    \n\x11FileTransferBlock\x12\x10\n\x02id\x18\x01\x20\x01(\x05R\x02idB\0\
    \x12\x1b\n\x08file_num\x18\x02\x20\x01(\x11R\x07fileNumB\0\x12\x14\n\x04\
    data\x18\x03\x20\x01(\x0cR\x04dataB\0\x12\x20\n\ncompressed\x18\x04\x20\
    \x01(\x08R\ncompressedB\0:\0\"\\\n\x11FileTransferError\x12\x10\n\x02id\
    \x18\x01\x20\x01(\x05R\x02idB\0\x12\x16\n\x05error\x18\x02\x20\x01(\tR\
    \x05errorB\0\x12\x1b\n\x08file_num\x18\x03\x20\x01(\x11R\x07fileNumB\0:\
    \0\"l\n\x17FileTransferSendRequest\x12\x10\n\x02id\x18\x01\x20\x01(\x05R\
    \x02idB\0\x12\x14\n\x04path\x18\x02\x20\x01(\tR\x04pathB\0\x12'\n\x0einc\
    lude_hidden\x18\x03\x20\x01(\x08R\rincludeHiddenB\0:\0\"C\n\x10FileTrans\
    ferDone\x12\x10\n\x02id\x18\x01\x20\x01(\x05R\x02idB\0\x12\x1b\n\x08file\
    _num\x18\x02\x20\x01(\x11R\x07fileNumB\0:\0\"n\n\x1aFileTransferReceiveR\
    equest\x12\x10\n\x02id\x18\x01\x20\x01(\x05R\x02idB\0\x12\x14\n\x04path\
    \x18\x02\x20\x01(\tR\x04pathB\0\x12&\n\x05files\x18\x03\x20\x03(\x0b2\
    \x0e.hbb.FileEntryR\x05filesB\0:\0\"Y\n\rFileRemoveDir\x12\x10\n\x02id\
    \x18\x01\x20\x01(\x05R\x02idB\0\x12\x14\n\x04path\x18\x02\x20\x01(\tR\
    \x04pathB\0\x12\x1e\n\trecursive\x18\x03\x20\x01(\x08R\trecursiveB\0:\0\
    \"W\n\x0eFileRemoveFile\x12\x10\n\x02id\x18\x01\x20\x01(\x05R\x02idB\0\
    \x12\x14\n\x04path\x18\x02\x20\x01(\tR\x04pathB\0\x12\x1b\n\x08file_num\
    \x18\x03\x20\x01(\x11R\x07fileNumB\0:\0\"9\n\rFileDirCreate\x12\x10\n\
    \x02id\x18\x01\x20\x01(\x05R\x02idB\0\x12\x14\n\x04path\x18\x02\x20\x01(\
    \tR\x04pathB\0:\0\"\x7f\n\rSwitchDisplay\x12\x1a\n\x07display\x18\x01\
    \x20\x01(\x05R\x07displayB\0\x12\x0e\n\x01x\x18\x02\x20\x01(\x11R\x01xB\
    \0\x12\x0e\n\x01y\x18\x03\x20\x01(\x11R\x01yB\0\x12\x16\n\x05width\x18\
    \x04\x20\x01(\x05R\x05widthB\0\x12\x18\n\x06height\x18\x05\x20\x01(\x05R\
    \x06heightB\0:\0\"a\n\x0ePermissionInfo\x121\n\npermission\x18\x01\x20\
    \x01(\x0e2\x0f.hbb.PermissionR\npermissionB\0\x12\x1a\n\x07enabled\x18\
    \x02\x20\x01(\x08R\x07enabledB\0:\0\"\xea\x03\n\rOptionMessage\x128\n\ri\
    mage_quality\x18\x01\x20\x01(\x0e2\x11.hbb.ImageQualityR\x0cimageQuality\
    B\0\x12F\n\x16lock_after_session_end\x18\x02\x20\x01(\x0e2\x0f.hbb.BoolO\
    ptionR\x13lockAfterSessionEndB\0\x12?\n\x12show_remote_cursor\x18\x03\
    \x20\x01(\x0e2\x0f.hbb.BoolOptionR\x10showRemoteCursorB\0\x124\n\x0cpriv\
    acy_mode\x18\x04\x20\x01(\x0e2\x0f.hbb.BoolOptionR\x0bprivacyModeB\0\x12\
    2\n\x0bblock_input\x18\x05\x20\x01(\x0e2\x0f.hbb.BoolOptionR\nblockInput\
    B\0\x122\n\x14custom_image_quality\x18\x06\x20\x01(\x05R\x12customImageQ\
    ualityB\0\x126\n\rdisable_audio\x18\x07\x20\x01(\x0e2\x0f.hbb.BoolOption\
    R\x0cdisableAudioB\0\x12>\n\x11disable_clipboard\x18\x08\x20\x01(\x0e2\
    \x0f.hbb.BoolOptionR\x10disableClipboardB\0:\0\"F\n\tTestDelay\x12\x14\n\
    \x04time\x18\x01\x20\x01(\x03R\x04timeB\0\x12!\n\x0bfrom_client\x18\x02\
    \x20\x01(\x08R\nfromClientB\0:\0\"e\n\tPublicKey\x12+\n\x10asymmetric_va\
    lue\x18\x01\x20\x01(\x0cR\x0fasymmetricValueB\0\x12)\n\x0fsymmetric_valu\
    e\x18\x02\x20\x01(\x0cR\x0esymmetricValueB\0:\0\"0\n\x08SignedId\x12\x10\
    \n\x02id\x18\x01\x20\x01(\x0cR\x02idB\0\x12\x10\n\x02pk\x18\x02\x20\x01(\
    \x0cR\x02pkB\0:\0\"P\n\x0bAudioFormat\x12!\n\x0bsample_rate\x18\x01\x20\
    \x01(\rR\nsampleRateB\0\x12\x1c\n\x08channels\x18\x02\x20\x01(\rR\x08cha\
    nnelsB\0:\0\"$\n\nAudioFrame\x12\x14\n\x04data\x18\x01\x20\x01(\x0cR\x04\
    dataB\0:\0\"\x86\x03\n\x04Misc\x127\n\x0cchat_message\x18\x04\x20\x01(\
    \x0b2\x10.hbb.ChatMessageH\0R\x0bchatMessageB\0\x12=\n\x0eswitch_display\
    \x18\x05\x20\x01(\x0b2\x12.hbb.SwitchDisplayH\0R\rswitchDisplayB\0\x12@\
    \n\x0fpermission_info\x18\x06\x20\x01(\x0b2\x13.hbb.PermissionInfoH\0R\
    \x0epermissionInfoB\0\x12.\n\x06option\x18\x07\x20\x01(\x0b2\x12.hbb.Opt\
    ionMessageH\0R\x06optionB\0\x127\n\x0caudio_format\x18\x08\x20\x01(\x0b2\
    \x10.hbb.AudioFormatH\0R\x0baudioFormatB\0\x12%\n\x0cclose_reason\x18\t\
    \x20\x01(\tH\0R\x0bcloseReasonB\0\x12'\n\rrefresh_video\x18\n\x20\x01(\
    \x08H\0R\x0crefreshVideoB\0B\t\n\x05union\x12\0:\0\"\xfc\x06\n\x07Messag\
    e\x12.\n\tsigned_id\x18\x03\x20\x01(\x0b2\r.hbb.SignedIdH\0R\x08signedId\
    B\0\x121\n\npublic_key\x18\x04\x20\x01(\x0b2\x0e.hbb.PublicKeyH\0R\tpubl\
    icKeyB\0\x121\n\ntest_delay\x18\x05\x20\x01(\x0b2\x0e.hbb.TestDelayH\0R\
    \ttestDelayB\0\x124\n\x0bvideo_frame\x18\x06\x20\x01(\x0b2\x0f.hbb.Video\
    FrameH\0R\nvideoFrameB\0\x12:\n\rlogin_request\x18\x07\x20\x01(\x0b2\x11\
    .hbb.LoginRequestH\0R\x0cloginRequestB\0\x12=\n\x0elogin_response\x18\
    \x08\x20\x01(\x0b2\x12.hbb.LoginResponseH\0R\rloginResponseB\0\x12!\n\
    \x04hash\x18\t\x20\x01(\x0b2\t.hbb.HashH\0R\x04hashB\0\x124\n\x0bmouse_e\
    vent\x18\n\x20\x01(\x0b2\x0f.hbb.MouseEventH\0R\nmouseEventB\0\x124\n\
    \x0baudio_frame\x18\x0b\x20\x01(\x0b2\x0f.hbb.AudioFrameH\0R\naudioFrame\
    B\0\x124\n\x0bcursor_data\x18\x0c\x20\x01(\x0b2\x0f.hbb.CursorDataH\0R\n\
    cursorDataB\0\x12@\n\x0fcursor_position\x18\r\x20\x01(\x0b2\x13.hbb.Curs\
    orPositionH\0R\x0ecursorPositionB\0\x12\x1f\n\tcursor_id\x18\x0e\x20\x01\
    (\x04H\0R\x08cursorIdB\0\x12.\n\tkey_event\x18\x0f\x20\x01(\x0b2\r.hbb.K\
    eyEventH\0R\x08keyEventB\0\x120\n\tclipboard\x18\x10\x20\x01(\x0b2\x0e.h\
    bb.ClipboardH\0R\tclipboardB\0\x124\n\x0bfile_action\x18\x11\x20\x01(\
    \x0b2\x0f.hbb.FileActionH\0R\nfileActionB\0\x12:\n\rfile_response\x18\
    \x12\x20\x01(\x0b2\x11.hbb.FileResponseH\0R\x0cfileResponseB\0\x12!\n\
    \x04misc\x18\x13\x20\x01(\x0b2\t.hbb.MiscH\0R\x04miscB\0B\t\n\x05union\
    \x12\0:\0*\xaa\x08\n\nControlKey\x12\t\n\x03Alt\x10\x01\x1a\0\x12\x0f\n\
    \tBackspace\x10\x02\x1a\0\x12\x0e\n\x08CapsLock\x10\x03\x1a\0\x12\r\n\
    \x07Control\x10\x04\x1a\0\x12\x0c\n\x06Delete\x10\x05\x1a\0\x12\x0f\n\tD\
    ownArrow\x10\x06\x1a\0\x12\t\n\x03End\x10\x07\x1a\0\x12\x0c\n\x06Escape\
    \x10\x08\x1a\0\x12\x08\n\x02F1\x10\t\x1a\0\x12\t\n\x03F10\x10\n\x1a\0\
    \x12\t\n\x03F11\x10\x0b\x1a\0\x12\t\n\x03F12\x10\x0c\x1a\0\x12\x08\n\x02\
    F2\x10\r\x1a\0\x12\x08\n\x02F3\x10\x0e\x1a\0\x12\x08\n\x02F4\x10\x0f\x1a\
    \0\x12\x08\n\x02F5\x10\x10\x1a\0\x12\x08\n\x02F6\x10\x11\x1a\0\x12\x08\n\
    \x02F7\x10\x12\x1a\0\x12\x08\n\x02F8\x10\x13\x1a\0\x12\x08\n\x02F9\x10\
    \x14\x1a\0\x12\n\n\x04Home\x10\x15\x1a\0\x12\x0f\n\tLeftArrow\x10\x16\
    \x1a\0\x12\n\n\x04Meta\x10\x17\x1a\0\x12\x0c\n\x06Option\x10\x18\x1a\0\
    \x12\x0e\n\x08PageDown\x10\x19\x1a\0\x12\x0c\n\x06PageUp\x10\x1a\x1a\0\
    \x12\x0c\n\x06Return\x10\x1b\x1a\0\x12\x10\n\nRightArrow\x10\x1c\x1a\0\
    \x12\x0b\n\x05Shift\x10\x1d\x1a\0\x12\x0b\n\x05Space\x10\x1e\x1a\0\x12\t\
    \n\x03Tab\x10\x1f\x1a\0\x12\r\n\x07UpArrow\x10\x20\x1a\0\x12\r\n\x07Nump\
    ad0\x10!\x1a\0\x12\r\n\x07Numpad1\x10\"\x1a\0\x12\r\n\x07Numpad2\x10#\
    \x1a\0\x12\r\n\x07Numpad3\x10$\x1a\0\x12\r\n\x07Numpad4\x10%\x1a\0\x12\r\
    \n\x07Numpad5\x10&\x1a\0\x12\r\n\x07Numpad6\x10'\x1a\0\x12\r\n\x07Numpad\
    7\x10(\x1a\0\x12\r\n\x07Numpad8\x10)\x1a\0\x12\r\n\x07Numpad9\x10*\x1a\0\
    \x12\x0c\n\x06Cancel\x10+\x1a\0\x12\x0b\n\x05Clear\x10,\x1a\0\x12\n\n\
    \x04Menu\x10-\x1a\0\x12\x0b\n\x05Pause\x10.\x1a\0\x12\n\n\x04Kana\x10/\
    \x1a\0\x12\x0c\n\x06Hangul\x100\x1a\0\x12\x0b\n\x05Junja\x101\x1a\0\x12\
    \x0b\n\x05Final\x102\x1a\0\x12\x0b\n\x05Hanja\x103\x1a\0\x12\x0b\n\x05Ka\
    nji\x104\x1a\0\x12\r\n\x07Convert\x105\x1a\0\x12\x0c\n\x06Select\x106\
    \x1a\0\x12\x0b\n\x05Print\x107\x1a\0\x12\r\n\x07Execute\x108\x1a\0\x12\
    \x0e\n\x08Snapshot\x109\x1a\0\x12\x0c\n\x06Insert\x10:\x1a\0\x12\n\n\x04\
    Help\x10;\x1a\0\x12\x0b\n\x05Sleep\x10<\x1a\0\x12\x0f\n\tSeparator\x10=\
    \x1a\0\x12\x0c\n\x06Scroll\x10>\x1a\0\x12\r\n\x07NumLock\x10?\x1a\0\x12\
    \n\n\x04RWin\x10@\x1a\0\x12\n\n\x04Apps\x10A\x1a\0\x12\x0e\n\x08Multiply\
    \x10B\x1a\0\x12\t\n\x03Add\x10C\x1a\0\x12\x0e\n\x08Subtract\x10D\x1a\0\
    \x12\r\n\x07Decimal\x10E\x1a\0\x12\x0c\n\x06Divide\x10F\x1a\0\x12\x0c\n\
    \x06Equals\x10G\x1a\0\x12\x11\n\x0bNumpadEnter\x10H\x1a\0\x12\x0c\n\x06R\
    Shift\x10I\x1a\0\x12\x0e\n\x08RControl\x10J\x1a\0\x12\n\n\x04RAlt\x10K\
    \x1a\0\x12\x10\n\nCtrlAltDel\x10d\x1a\0\x12\x10\n\nLockScreen\x10e\x1a\0\
    \x1a\0*R\n\x08FileType\x12\t\n\x03Dir\x10\x01\x1a\0\x12\r\n\x07DirLink\
    \x10\x02\x1a\0\x12\x0e\n\x08DirDrive\x10\x03\x1a\0\x12\n\n\x04File\x10\
    \x04\x1a\0\x12\x0e\n\x08FileLink\x10\x05\x1a\0\x1a\0*<\n\nPermission\x12\
    \x0e\n\x08Keyboard\x10\x01\x1a\0\x12\x0f\n\tClipboard\x10\x02\x1a\0\x12\
    \x0b\n\x05Audio\x10\x03\x1a\0\x1a\0*E\n\x0cImageQuality\x12\x0c\n\x06Not\
    Set\x10\0\x1a\0\x12\t\n\x03Low\x10\x02\x1a\0\x12\x0e\n\x08Balanced\x10\
    \x03\x1a\0\x12\n\n\x04Best\x10\x04\x1a\0\x1a\0*1\n\nBoolOption\x12\x0c\n\
    \x06NotSet\x10\0\x1a\0\x12\x08\n\x02No\x10\x01\x1a\0\x12\t\n\x03Yes\x10\
    \x02\x1a\0\x1a\0B\0b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::LazyV2<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::LazyV2::INIT;
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::new();
        let mut messages = ::std::vec::Vec::new();
        messages.push(VP9::generated_message_descriptor_data());
        messages.push(VP9s::generated_message_descriptor_data());
        messages.push(RGB::generated_message_descriptor_data());
        messages.push(YUV::generated_message_descriptor_data());
        messages.push(VideoFrame::generated_message_descriptor_data());
        messages.push(DisplayInfo::generated_message_descriptor_data());
        messages.push(PortForward::generated_message_descriptor_data());
        messages.push(FileTransfer::generated_message_descriptor_data());
        messages.push(LoginRequest::generated_message_descriptor_data());
        messages.push(ChatMessage::generated_message_descriptor_data());
        messages.push(PeerInfo::generated_message_descriptor_data());
        messages.push(LoginResponse::generated_message_descriptor_data());
        messages.push(MouseEvent::generated_message_descriptor_data());
        messages.push(KeyEvent::generated_message_descriptor_data());
        messages.push(CursorData::generated_message_descriptor_data());
        messages.push(CursorPosition::generated_message_descriptor_data());
        messages.push(Hash::generated_message_descriptor_data());
        messages.push(Clipboard::generated_message_descriptor_data());
        messages.push(FileEntry::generated_message_descriptor_data());
        messages.push(FileDirectory::generated_message_descriptor_data());
        messages.push(ReadDir::generated_message_descriptor_data());
        messages.push(ReadAllFiles::generated_message_descriptor_data());
        messages.push(FileAction::generated_message_descriptor_data());
        messages.push(FileTransferCancel::generated_message_descriptor_data());
        messages.push(FileResponse::generated_message_descriptor_data());
        messages.push(FileTransferBlock::generated_message_descriptor_data());
        messages.push(FileTransferError::generated_message_descriptor_data());
        messages.push(FileTransferSendRequest::generated_message_descriptor_data());
        messages.push(FileTransferDone::generated_message_descriptor_data());
        messages.push(FileTransferReceiveRequest::generated_message_descriptor_data());
        messages.push(FileRemoveDir::generated_message_descriptor_data());
        messages.push(FileRemoveFile::generated_message_descriptor_data());
        messages.push(FileDirCreate::generated_message_descriptor_data());
        messages.push(SwitchDisplay::generated_message_descriptor_data());
        messages.push(PermissionInfo::generated_message_descriptor_data());
        messages.push(OptionMessage::generated_message_descriptor_data());
        messages.push(TestDelay::generated_message_descriptor_data());
        messages.push(PublicKey::generated_message_descriptor_data());
        messages.push(SignedId::generated_message_descriptor_data());
        messages.push(AudioFormat::generated_message_descriptor_data());
        messages.push(AudioFrame::generated_message_descriptor_data());
        messages.push(Misc::generated_message_descriptor_data());
        messages.push(Message::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::new();
        enums.push(ControlKey::generated_enum_descriptor_data());
        enums.push(FileType::generated_enum_descriptor_data());
        enums.push(Permission::generated_enum_descriptor_data());
        enums.push(ImageQuality::generated_enum_descriptor_data());
        enums.push(BoolOption::generated_enum_descriptor_data());
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}
